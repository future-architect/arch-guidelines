import{_ as l,C as a,c as i,o as s,G as n,a4 as r}from"./chunks/framework.BJEXY-5A.js";const o="/arch-guidelines/assets/congratulations_1st_merged.LopxdouJ.png",f=JSON.parse('{"title":"コードレビューガイドライン","description":"","frontmatter":{"sidebarDepth":4,"title":"コードレビューガイドライン","author":"フューチャー株式会社","head":[["meta",{"name":"keywords","content":"コードレビュー"}]]},"headers":[],"relativePath":"documents/forCodeReview/code_review.md","filePath":"documents/forCodeReview/code_review.md"}'),d={name:"documents/forCodeReview/code_review.md"};function p(h,t,c,u,g,b){const e=a("page-title");return s(),i("div",null,[n(e),t[0]||(t[0]=r(`<p>本ガイドラインは、世の中のシステム開発プロジェクトのために無償で提供する。<br> ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社（以下、フューチャー）は一切の責務を負わないものとする。<br> また、掲載している情報は予告なく変更する場合があるため、あらかじめご了承いただきたい。</p><div class="warning custom-block"><p class="custom-block-title">免責事項: 有志で作成したドキュメントである</p><ul><li>フューチャーには多様なプロジェクトが存在し、それぞれの状況に合わせて工夫された開発プロセスや高度な開発支援環境が存在する。本ガイドラインはフューチャーの全ての部署／プロジェクトで適用されているわけではなく、有志が観点を持ち寄って新たに整理したものである</li><li>相容れない部分があればその領域を書き換えて利用することを想定している <ul><li>プロジェクト固有の背景や要件への配慮は、ガイドライン利用者が最終的に判断すること</li></ul></li><li>本ガイドラインに必ず従うことは求めておらず、設計案の提示と、それらの評価観点を利用者に提供することを主目的としている</li></ul></div><h2 id="はじめに" tabindex="-1">はじめに <a class="header-anchor" href="#はじめに" aria-label="Permalink to &quot;はじめに&quot;">​</a></h2><p><a href="https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com/" target="_blank" rel="noreferrer">プログラマが知るべき97のこと</a> の14個目に「コードレビュー」について記述がある。コードレビューの目的は「コードの質を上げ、欠陥を減らすため」だけではなく、「チーム全員に同じ知識を共有させること、またコーディングにおいて全員が守るべきガイドラインを確立すること」が大切だとある。そして「 レビューを楽しいものにすること」がおそらく最も有効だとある。</p><p>コードレビューを楽しい場にするためにも、レビュアー／レビュイー が同じ方向性を向くことが重要である。同時に、人によってコメントなどの表現が揺れ、それにより認識齟齬があると楽しむ以前の問題であるため、守るべきルールも存在するはずである。このガイドラインは推奨する行動と、守るべきルールの両方を定義し、コードレビューをより有意義で学びが多く、生産性と品質を高める場とすることを目指す。</p><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://about.gitlab.com/ja-jp/topics/version-control/what-is-code-review/" target="_blank" rel="noreferrer">コードレビューとは | GitLab</a> にも似た旨の記載がある</p></div><h2 id="定義" tabindex="-1">定義 <a class="header-anchor" href="#定義" aria-label="Permalink to &quot;定義&quot;">​</a></h2><ul><li><strong>レビュアー</strong>: レビューを行う側の担当者</li><li><strong>レビュイー</strong>: レビューを依頼する側の担当者。プルリクエストを起票する開発者でもある</li><li><strong>プルリクエスト</strong>: GitLabではマージリクエストともいうが、本ガイドラインではプルリクエストに統一して呼称する</li></ul><h2 id="適用範囲" tabindex="-1">適用範囲 <a class="header-anchor" href="#適用範囲" aria-label="Permalink to &quot;適用範囲&quot;">​</a></h2><p>GitHubやGitLabなどのサービスを利用した、コーディングについてのレビューのみを対象とする。</p><p>プロジェクト計画によっては、開発プロセスを複数の「フェーズ」に分割し、各フェーズの終了時点で「フェーズレビュー」を挟むようなケースも考えられるが、それらは対象外とする。</p><h2 id="前提条件" tabindex="-1">前提条件 <a class="header-anchor" href="#前提条件" aria-label="Permalink to &quot;前提条件&quot;">​</a></h2><h3 id="利用するgitブランチ戦略" tabindex="-1">利用するGitブランチ戦略 <a class="header-anchor" href="#利用するgitブランチ戦略" aria-label="Permalink to &quot;利用するGitブランチ戦略&quot;">​</a></h3><p><a href="https://future-architect.github.io/coding-standards/documents/forGitBranch/git_branch_standards.html#%E3%83%95%E3%82%99%E3%83%A9%E3%83%B3%E3%83%81%E6%88%A6%E7%95%A5%E3%81%AE%E9%81%B8%E5%AE%9A" target="_blank" rel="noreferrer">Gitブランチフロー規約 &gt; ブランチ戦略の選定</a> にある、以下の2パターンのいずれかを利用しているとする。</p><ul><li><code>Lite GitLab Flow</code></li><li><code>GitLab Flow</code></li></ul><p>そのため当然であるが、全ての機能開発や不具合修正に、<code>feature</code> ブランチを使用したプルリクエストを経由してマージする方針を取る。その他の <code>feature</code> ブランチから <code>develop</code> ブランチへのマージ方法などもGitブランチフローに記載した推奨事項に則る。</p><h3 id="事前設定-github" tabindex="-1">事前設定（GitHub） <a class="header-anchor" href="#事前設定-github" aria-label="Permalink to &quot;事前設定（GitHub）&quot;">​</a></h3><p><a href="https://future-architect.github.io/coding-standards/documents/forGitBranch/git_branch_standards.html#git-config%E6%8E%A8%E5%A5%A8%E8%A8%AD%E5%AE%9A" target="_blank" rel="noreferrer">Gitブランチフロー規約</a> に則った設定を実施する。例えば、ブランチ保護やレビューの設定には以下の内容がある。できるかぎり自動化やテンプレートを用意することで、個々人が考慮すべきことを減らすことで運用負荷を下げ、規則を形骸化にせず実効性を上げることを基本姿勢とする。</p><table tabindex="0"><thead><tr><th style="text-align:left;">設定項目</th><th style="text-align:left;">設定例</th><th style="text-align:left;">説明</th></tr></thead><tbody><tr><td style="text-align:left;">Require a pull request before merging</td><td style="text-align:left;">✔</td><td style="text-align:left;">プルリクエストを必須とする</td></tr><tr><td style="text-align:left;">Require approvals</td><td style="text-align:left;">1</td><td style="text-align:left;">1名以上の承認を必須とする</td></tr><tr><td style="text-align:left;">Require status checks to pass before merging</td><td style="text-align:left;">✔</td><td style="text-align:left;">CIの成功をマージ条件とする</td></tr><tr><td style="text-align:left;"><a href="https://docs.github.com/ja/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners" target="_blank" rel="noreferrer">CODEOWNERS</a></td><td style="text-align:left;">(省略)</td><td style="text-align:left;">重要ファイル（例えば、ddl.sqlやopenapi.yamlなど）は承認が必須なレビュアーを指定する</td></tr><tr><td style="text-align:left;"><a href="https://docs.github.com/ja/repositories/working-with-files/managing-files/customizing-how-changed-files-appear-on-github" target="_blank" rel="noreferrer">linguist-generated=true</a></td><td style="text-align:left;">(省略)</td><td style="text-align:left;">ツールなどによる生成ファイルの差分を非表示にする .gitattributesの設定</td></tr></tbody></table><h3 id="機械的なチェックが可能な場合はciに寄せる方針としている" tabindex="-1">機械的なチェックが可能な場合はCIに寄せる方針としている <a class="header-anchor" href="#機械的なチェックが可能な場合はciに寄せる方針としている" aria-label="Permalink to &quot;機械的なチェックが可能な場合はCIに寄せる方針としている&quot;">​</a></h3><p>コードレビューのやり取りで、「コードフォーマットされていない」 「リンターを通していない」といった指摘は不毛である。そのため、CIでそれらを実行し、パスしているという前提条件を作ることが重要である。それにより、レビュアーは人間が本来見るべき点に集中できるためである。</p><p>例えば、下表のような内容はフォーマッタやリンターに寄せることができる可能性が高い。</p><table tabindex="0"><thead><tr><th style="text-align:left;">自動化可能だと考えられる指摘例</th><th style="text-align:left;">ツール例</th></tr></thead><tbody><tr><td style="text-align:left;">使われていないメソッドや関数</td><td style="text-align:left;">Pythonの場合、Flake8 など</td></tr><tr><td style="text-align:left;">デッドコード</td><td style="text-align:left;">Pythonの場合、Vultureなど</td></tr><tr><td style="text-align:left;">デバック用のログの残骸</td><td style="text-align:left;">JSの場合は、ESLint（console.logの検知など）。 Pythonの場合は、Pylintなど</td></tr><tr><td style="text-align:left;">不適切なレイヤーに対するimport</td><td style="text-align:left;">Pythonの場合、import-linterなど</td></tr><tr><td style="text-align:left;">//TODO コメントが残っている</td><td style="text-align:left;">JSでは、eslint-plugin-no-inline-commentsなど</td></tr><tr><td style="text-align:left;">フォーマッタが適用されているかどうか</td><td style="text-align:left;">JSでは <code>prettier --check &quot;yourfile.js&quot;</code>、Pythonでは <code>black --check yourfile.py</code> など</td></tr></tbody></table><h3 id="ciによるレビューコメント連携を行う" tabindex="-1">CIによるレビューコメント連携を行う <a class="header-anchor" href="#ciによるレビューコメント連携を行う" aria-label="Permalink to &quot;CIによるレビューコメント連携を行う&quot;">​</a></h3><p>Linterなどの検知結果をreviewdogなどと連携することで、形式的な指摘はツール側に寄せる。それにより開発者個人個人のやり取りを減らし、本当に集中すべき事項に時間を割くこととする。</p><h3 id="プルリクエストテンプレートでチェックリストを設ける" tabindex="-1">プルリクエストテンプレートでチェックリストを設ける <a class="header-anchor" href="#プルリクエストテンプレートでチェックリストを設ける" aria-label="Permalink to &quot;プルリクエストテンプレートでチェックリストを設ける&quot;">​</a></h3><p>プルリクエストにチェックリストを追加し、レビュー依頼前にセルフチェックする運用を採用するチームも多い。チェックリストが多すぎると形骸化するため、項目は具体的にする（例: 設計ドキュメントを同時に直したか？など）とともに、必要最低限の項目に留め、チームの成熟度に応じて適時見直す運用とする。</p><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://docs.github.com/ja/communities/using-templates-to-encourage-useful-issues-and-pull-requests/creating-a-pull-request-template-for-your-repository" target="_blank" rel="noreferrer">リポジトリ用のプルリクエストテンプレートの作成 - GitHub Docs</a></p></div><h3 id="チームで合意した開発規約が存在し遵守しつつ育てる" tabindex="-1">チームで合意した開発規約が存在し遵守しつつ育てる <a class="header-anchor" href="#チームで合意した開発規約が存在し遵守しつつ育てる" aria-label="Permalink to &quot;チームで合意した開発規約が存在し遵守しつつ育てる&quot;">​</a></h3><p>以下のような、チームで守るべきと合意形成されたコーディング規約や命名ルールが存在し、これらの内容をチームで改善し続ける運用であることを前提とする。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html" target="_blank" rel="noreferrer">Javaコーディング規約</a></li><li><a href="https://future-architect.github.io/coding-standards/documents/forSQL/SQL%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84%EF%BC%88PostgreSQL%EF%BC%89.html" target="_blank" rel="noreferrer">SQLコーディング規約</a></li><li><a href="https://future-architect.github.io/coding-standards/documents/forAWSResource/AWS%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E5%91%BD%E5%90%8D%E8%A6%8F%E7%B4%84.html" target="_blank" rel="noreferrer">AWSインフラ命名規約</a></li><li><a href="https://future-architect.github.io/coding-standards/documents/forOpenAPISpecification/OpenAPI_Specification_3.0.3.html" target="_blank" rel="noreferrer">OpenAPI Specification 3.0.3規約</a></li></ul><h2 id="レビュー観点" tabindex="-1">レビュー観点 <a class="header-anchor" href="#レビュー観点" aria-label="Permalink to &quot;レビュー観点&quot;">​</a></h2><p>「フォーマッタやリンター」などのツールをCIと組み合わせることで、レビュアーが見るべき領域を減らすことができる。また、「チームで合意された開発規約」をレビュイーが遵守できれば、ツールがカバーできない領域に対してもレビュアーの負担減に繋がる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">大分類</th><th style="text-align:left;">中分類</th><th style="text-align:left;">小分類</th><th style="text-align:left;">レビュイーが気にすべきか</th><th style="text-align:left;">レビュアーが見るべきか</th></tr></thead><tbody><tr><td style="text-align:left;">開発規約に記載済</td><td style="text-align:left;">ツールでカバー可能</td><td style="text-align:left;"></td><td style="text-align:left;">⚠️ツール補助あり</td><td style="text-align:left;">不要</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">ツールでカバー不可</td><td style="text-align:left;"></td><td style="text-align:left;">✅️規約を準拠しているか確認する必要がある</td><td style="text-align:left;">✅️規約を準拠しているか確認する必要がある</td></tr><tr><td style="text-align:left;">開発規約に未記載</td><td style="text-align:left;">規約に記載可能</td><td style="text-align:left;"></td><td style="text-align:left;">⚠️Yesだが、難しい場合が多い</td><td style="text-align:left;">✅️言語化して開発規約に追加すべき</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">規約に記載不可</td><td style="text-align:left;">機能要件の充足</td><td style="text-align:left;">✅️</td><td style="text-align:left;">✅️</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;">文脈依存が強く汎化不可</td><td style="text-align:left;">⚠️Yesだが、難しい場合が多い</td><td style="text-align:left;">✅️個別の命名や、他に類似の実装パターンがない場合は個別に見るしかない</td></tr></tbody></table><p>レビュー観点は、開発しているプロダクトの性質、開発体制、採用技術で大きく変動するためここで詳細は述べない。</p><p>基本的には、チームで合意形成された開発規約（参考: <a href="https://jisou-programmer.beproud.jp/%E5%AE%9F%E8%A3%85%E3%81%AE%E9%80%B2%E3%82%81%E6%96%B9/39-%E9%96%8B%E7%99%BA%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88.html" target="_blank" rel="noreferrer">開発アーキテクチャドキュメント</a>）やツール（リンターやフォーマッタ）を充実させる方向に寄せるべきである。以下に、開発規約にはどのような内容を記載すべきかを以下に参考情報としてまとめる。</p><div class="language-md vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">md</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"># 開発ガイドライン（例）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## 仕様確認</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 開発の入力情報となる、設計ドキュメント、チケットなどの前提が正しいかどうかの確認は開発者が行う</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> もし、入力情報が疑わしい場合は開発者自身が有識者に確認、必要に応じてチケットを起票して、ドキュメント修正を行うか、修正依頼を行う</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## 機能要件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">フロントエンド:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 設計書通りの見た目となっているか確認する</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 必須/任意、Readonlyなど表示仕様は適切か確認する</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表示項目の編集仕様（時刻など）は他機能と整合性が取れているか確認する</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">バックエンド:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 環境によって変わる値がハードコードになっていないか</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## 性能観点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SQL:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> N+1クエリはなるべく避けるようにする</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> アプリケーション側でジョインしてはならない</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SQLの検索条件で、パーティションキーの指定が抜けていないように注意する</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## 可用性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 外部API呼び出し時などでタイムアウトは設定されているか</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 外部API呼び出し時に、リトライ設定は行っているか</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## 可読性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-light-text-decoration:underline;--shiki-dark:#DBEDFF;--shiki-dark-text-decoration:underline;">命名規則</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">](</span><span style="--shiki-light:#24292E;--shiki-light-text-decoration:underline;--shiki-dark:#E1E4E8;--shiki-dark-text-decoration:underline;">https://java-standard.example.com</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) に従う</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> コードコメントは、JavaDoc形式（Markdown）をなるべく使用する</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## ログ</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loggerはxxxを利用すること</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ループ内で大量に呼び出される場合は、debugログであっても性能劣化懸念があるため不可とする</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## テスト</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> カバレッジはC0 90%程度が目安</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> バックエンドについては、デシジョンテーブル（決定表）からテストケースを作成する</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><div class="tip custom-block"><p class="custom-block-title">関連</p><p><a href="https://fujiharuka.github.io/google-eng-practices-ja/ja/review/reviewer/looking-for.html" target="_blank" rel="noreferrer">コードレビューの観点 | google-eng-practices-ja</a></p></div><h2 id="レビュイーの推奨行動" tabindex="-1">レビュイーの推奨行動 <a class="header-anchor" href="#レビュイーの推奨行動" aria-label="Permalink to &quot;レビュイーの推奨行動&quot;">​</a></h2><h3 id="重要な変更の場合、方向性を事前にチームと合意形成しておく" tabindex="-1">重要な変更の場合、方向性を事前にチームと合意形成しておく <a class="header-anchor" href="#重要な変更の場合、方向性を事前にチームと合意形成しておく" aria-label="Permalink to &quot;重要な変更の場合、方向性を事前にチームと合意形成しておく&quot;">​</a></h3><p>実装する内容が、設計書に基づく新規機能の改修や、不具合改修でチケットに原因分析や対応方針が明記されている場合は、チーム内で改めて対応方針のすり合わせを行う必要はない。</p><p>考慮の残がありかつ、すでに稼働済みの機能の挙動変更を行う場合や、原因が特定されていない不具合修正の場合は、以下の内容をチームで合意形成してから実装に入った方が、認識齟齬や手戻りを減らせ、レビュイー／レビュアー双方の負荷を下げることができる</p><ul><li>（不具合対応の場合） <ul><li>事象</li><li>業務影響</li><li>システム影響</li><li>原因分析</li><li>対応方針</li><li>この変更に伴う影響範囲（分割リリースを行うかどうか）</li></ul></li><li>（既存機能の挙動変更） <ul><li>変更理由（顧客要望）が何か</li><li>対応方針</li><li>この変更に伴う影響範囲（分割リリースを行うかどうか）</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">スキーマファイルは事前にレビューしておくと手戻りを防ぎやすい</p><p>「WebAPIのスキーマ定義」や「DBスキーマ定義」など、システム構成要素の境界となるようなスキーマファイルの変更は、システムに対する影響度が大きいためレビュアーとしても設計を妥協しにくい。また、これらのファイルに指摘が入ると、ほぼ必然的にアプリケーションコードも修正することになるため、手戻りも大きくなる。これら境界となるようなファイルは先行して、Draftプルリクエストでレビュアーに確認してもらってから作業する工夫は有効である。また、そのような開発ルールにするチームも多い。</p></div><p>参考: <a href="https://user-first.ikyu.co.jp/entry/2024/12/09/143648" target="_blank" rel="noreferrer">Design Doc でチームを跨いだ開発を円滑に行う - 一休.com Developers Blog</a></p><h3 id="プルリクエストの単位を小さくする" tabindex="-1">プルリクエストの単位を小さくする <a class="header-anchor" href="#プルリクエストの単位を小さくする" aria-label="Permalink to &quot;プルリクエストの単位を小さくする&quot;">​</a></h3><p>複数の改修内容が単一のプルリクエストに含まれており、変更内容が多い（20ファイル以上などの）場合、レビュアーの負荷が高くなってしまう。コミットを意味のある粒度に保ちつつ細かくするか、プルリクエストの粒度を細かくするかの2通りの対応が考えられる。</p><p>推奨は以下の通り。</p><ul><li>プルリクエストの単位を小さくする</li><li>分割したという旨を、プルリクエストの説明に追記する</li><li>何が残りの作業であるかは、チケットやプルリクエストに記載し、レビュアーが把握できるようにする（作業漏れとして指摘すべきか判断可能にするため）</li></ul><div class="tip custom-block"><p class="custom-block-title">大きな変更の場合、目的別にプルリクエストを分ける</p><p>プルリクエストの粒度を細かくすることで、レビュアーの負荷を下げることができる。例えば、ある機能改修を行う際に、リファクタリングを行ってから作業をおこないたい場合は、リファクタリングのみを行うプルリクエストと、機能追加を行うプルリクエストを分けることがあげられる。なお、ローカル変数の名称を変更するといった小さな変更は、わざわざプルリクエストを分ける必要はない。</p></div><div class="tip custom-block"><p class="custom-block-title">プルリクエストを小さくすることは学習効果もある？</p><p><a href="https://tech.findy.co.jp/entry/2025/02/18/070000" target="_blank" rel="noreferrer">Findyの爆速成長を支えるエンジニア教育メソッド ~ 育成ノウハウの一部を初公開 ~ Findy Tech Blog</a>に以下の記述がある。</p><blockquote><p>手数に関しては、とにかく小さい修正でもいいので適切な粒度でPull requestを作り続け、大量のフィードバックを得るようにします。</p><p>量は質に転化すると言われているように、手数が増えれば増えるほど結果的に質と理解が深まっていき、最終的にはスピードが身に付きます。</p><p>また、指摘事項が多い場合はPull requestの粒度が大きすぎるケースが多く、そういったケースでは粒度を細かくしてPull requestを作り直してもらいます。一度に100個指摘されて100個覚えるよりも、1個指摘されて1個覚えることを100回繰り返すほうが覚えやすいからです。</p></blockquote><p>このように、学習観点でのプルリクエストの単位を小さくするメリットを説いている。一度に全てのことを覚えるのは誰にとっても難しいため、段階を追って1個ずつ学ぶことができるような進め方をすると良い。</p></div><h3 id="コミットメッセージはこだわらなくても良い" tabindex="-1">コミットメッセージはこだわらなくても良い <a class="header-anchor" href="#コミットメッセージはこだわらなくても良い" aria-label="Permalink to &quot;コミットメッセージはこだわらなくても良い&quot;">​</a></h3><p><a href="https://commitlint.js.org/" target="_blank" rel="noreferrer">commitlint</a> を適用し、レビュー負荷軽減のためコミットメッセージの統制を図るという考え方も存在する。</p><p>推奨は以下の通り。</p><ul><li>コミットメッセージは開発者の裁量に任せる <ul><li>「wip」や「リファクタリング」など荒くても良い</li></ul></li><li>コミットメッセージより、プルリクエストのタイトルに気を配る</li></ul><p>理由は以下。</p><ul><li>プルリクエストの単位を小さくする前提であるため、コミットの粒度やメッセージを気にすることによるメリットが小さい</li><li>Gitブランチ規約から、最終的にスカッシュマージするため重要度が下がる</li></ul><h3 id="プルリクエストのタイトルにプレフィックスを入れる" tabindex="-1">プルリクエストのタイトルにプレフィックスを入れる <a class="header-anchor" href="#プルリクエストのタイトルにプレフィックスを入れる" aria-label="Permalink to &quot;プルリクエストのタイトルにプレフィックスを入れる&quot;">​</a></h3><p>プルリクエストのタイトルに命名規則をもたせることで、レビュアーの負荷軽減に繋げることができる。また、履歴からのトラッキングが容易になる。</p><p>推奨は以下の通り。</p><ul><li>タイトルは <code>{type}: {subject}</code> や <code>{type}: {feature_id}: {subject}</code> という構成に従う</li><li>type は下表のいずれかを選択し、複数該当する場合はより上位にあるものを選ぶ</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">type</th><th style="text-align:left;">説明</th></tr></thead><tbody><tr><td style="text-align:left;">feat</td><td style="text-align:left;">新機能の追加</td></tr><tr><td style="text-align:left;">mod</td><td style="text-align:left;">機能変更（仕様変更）</td></tr><tr><td style="text-align:left;">fix</td><td style="text-align:left;">バグの修正</td></tr><tr><td style="text-align:left;">refactor</td><td style="text-align:left;">リファクタリング</td></tr><tr><td style="text-align:left;">docs</td><td style="text-align:left;">ドキュメンテーションの更新</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">ラベルとの使い分け</p><p>プルリクエストの<a href="https://docs.github.com/ja/issues/using-labels-and-milestones-to-track-work/managing-labels" target="_blank" rel="noreferrer">ラベル</a>でも同じ意図を持たせることができるが、レビュアーにとっての視認性を重視するため、重複した内容であってもタイトルにプレフィックスを含ませる。</p><p>関連: <a href="https://future-architect.github.io/coding-standards/documents/forGitBranch/git_branch_standards.html#%E3%83%A9%E3%83%98%E3%82%99%E3%83%AB%E8%A6%8F%E5%89%87" target="_blank" rel="noreferrer">Gitブランチフロー規約 &gt; ラベル</a></p></div><h3 id="差分-diff-を極小化することにこだわりすぎない" tabindex="-1">差分（diff）を極小化することにこだわりすぎない <a class="header-anchor" href="#差分-diff-を極小化することにこだわりすぎない" aria-label="Permalink to &quot;差分（diff）を極小化することにこだわりすぎない&quot;">​</a></h3><p>レビュー負荷軽減や、影響度の極小化の観点から、なるべく差分を小さくすることを志向した改修を行うべきか迷う場面がある。</p><p>推奨は以下の通り。</p><ul><li>あるべき変更を最優先とし、その後でレビュー負荷軽減のため差分を小さくできないか考える <ul><li>リファクタリングなど、可読性／保守性を上げる改善は継続する必要がある</li><li>差分を小さくするために、コードベースの改善活動を止めるのは本末転倒である（良いモノを作るためにコードレビューをしている面がある）</li></ul></li><li>必要に応じて、プルリクエストの分割を検討する</li></ul><div class="tip custom-block"><p class="custom-block-title">GitHubやGitLabでは空白のみの差分を無視できる</p><p>GitHubやGitLabではURLの最後に、 <code>?w=1</code> を付与することで、空白のみの差分を無視することができる（画面上からの設定も可能）。</p><p>例えば、Markdownテーブルに項目を編集するとフォーマッタにより大きな差分が出ることが多く、変更に対する心理的ハードルが上がってしまう。しかし、このオプションを利用することでレビュアーの負荷は下がり本質的なレビューに集中できる。もし、レビュアーがこのオプションを知らないようであれば、 <code>?w=1</code> つきのURLをプルリクエストのDescriptionやレビューコメントで追記すると良い。</p><ul><li><a href="https://github.blog/news-insights/product-news/ignore-white-space-in-code-review/" target="_blank" rel="noreferrer">Ignore white space in code review - The GitHub Blog</a></li></ul></div><h3 id="ファイルの移動やリネームと同時に大きく編集しない" tabindex="-1">ファイルの移動やリネームと同時に大きく編集しない <a class="header-anchor" href="#ファイルの移動やリネームと同時に大きく編集しない" aria-label="Permalink to &quot;ファイルの移動やリネームと同時に大きく編集しない&quot;">​</a></h3><p>リファクタリングや構成の整理で、ファイルの移動やリネームを行う場面は多々ある。</p><p>推奨は以下の通り。</p><ul><li>ファイルの移動やリネームと同時に、ファイル自体を大きく変更しない <ul><li>gitの同一ファイル判定が狂い、ファイルの削除＋ファイルの新規作成となり、該当ファイルの変更履歴が消える可能性があるため</li><li>レビュアーにとって、新規ファイル扱いになると、本当の差分がどれか画面上は分からず、確認コストが上がってしまうため</li></ul></li><li>どうしても同一プルリクエストでファイルのリネームと編集を行う必要がある場合は、以下の対応をする <ul><li><code>git mv</code> で操作してからファイルを変更する</li><li>ファイルの移動やリネームで、<code>git commit</code> し、その後にファイルの変更を行う</li></ul></li></ul><h3 id="作業途中のプルリクエストはdraftにする" tabindex="-1">作業途中のプルリクエストはDraftにする <a class="header-anchor" href="#作業途中のプルリクエストはdraftにする" aria-label="Permalink to &quot;作業途中のプルリクエストはDraftにする&quot;">​</a></h3><p>何かしらの理由で、マージされたくない作業途中の状態で、プルリクエストを作成したい場合がある。例えば、作業途中の内容を部分的にメンバーに確認してもらいたい場面や、セルフチェックが完了前に別タスクを行う必要が出た場合などがある。誤ってレビューやマージされたくない</p><p>推奨は以下の通り。</p><ul><li>GitHubにおいて、プルリクエストの<a href="https://docs.github.com/ja/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request" target="_blank" rel="noreferrer">ドラフトステータス</a>機能を利用して、誤操作を防ぐ <ul><li>誤認識、誤操作による作業を防ぐ</li><li>プルリクエストが滞留している状況で、レビュー待ちなのか作業中なのかが区別して可視化できるようにし、開発状況をマネージャーが把握しやすくするため</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">Draftプルリクエストの早期作成のススメ</p><p>作業途中であっても、早期にDraftプルリクエストを作成することで、作業の可視化／透明性に繋げることができる。他にも開発者が作業を再開しやすくなるなどメリットが大きいため、ローカルでの開発作業が完了する前の段階でDraftプルリクエストを利用することを推奨する。</p></div><h3 id="プルリクエスト本文にチケット番号や関連情報を貼る" tabindex="-1">プルリクエスト本文にチケット番号や関連情報を貼る <a class="header-anchor" href="#プルリクエスト本文にチケット番号や関連情報を貼る" aria-label="Permalink to &quot;プルリクエスト本文にチケット番号や関連情報を貼る&quot;">​</a></h3><p>トレーサビリティのため、チケット番号（のURL）や、設計検討したドキュメントのリンクや、議論スレッドのURLなどを、チケット本文に記載することで、後からトレース可能にする。チリツモであるがチームの開発生産性を上げることに繋がるため。</p><h3 id="チケット番号があるのであれば、プルリクエスト本文に重複記載は不要" tabindex="-1">チケット番号があるのであれば、プルリクエスト本文に重複記載は不要 <a class="header-anchor" href="#チケット番号があるのであれば、プルリクエスト本文に重複記載は不要" aria-label="Permalink to &quot;チケット番号があるのであれば、プルリクエスト本文に重複記載は不要&quot;">​</a></h3><p>作業目的（どういった要望／不具合に対する対応か）などは、作業チケットに記載されているのであれば、プルリクエスト本文での記述は不要である。<br> なお、サマリ事項だけ転記するなど、詳細な運用ルールはチームごとに決めて良い。</p><h3 id="長くなる場合はmarkdownの折りたたみを利用する" tabindex="-1">長くなる場合はMarkdownの折りたたみを利用する <a class="header-anchor" href="#長くなる場合はmarkdownの折りたたみを利用する" aria-label="Permalink to &quot;長くなる場合はMarkdownの折りたたみを利用する&quot;">​</a></h3><p>GitHubでは <code>&lt;details&gt;</code> タグで<a href="https://docs.github.com/ja/get-started/writing-on-github/working-with-advanced-formatting/organizing-information-with-collapsed-sections" target="_blank" rel="noreferrer">折りたたんだセクション</a>が作成可能である。例えば、単体テストケース化できないような動作確認を行い、かつ動作検証ログをエビデンスとして貼り付けるような場面では、折りたたんだセクションを活用することで、本文を簡潔に保つことができる。</p><div class="tip custom-block"><p class="custom-block-title">スラッシュコマンドを利用する</p><p><a href="https://docs.github.com/ja/issues/tracking-your-work-with-issues/using-issues/about-slash-commands" target="_blank" rel="noreferrer">スラッシュコマンド</a>を用いることで、簡単に折りたたみできる詳細領域を挿入できる。入力時に <code>/</code> を押すとメニューが表示されるため、「Details」を選択する。</p></div><h3 id="画像をエビデンスとして貼るべきかどうか" tabindex="-1">画像をエビデンスとして貼るべきかどうか <a class="header-anchor" href="#画像をエビデンスとして貼るべきかどうか" aria-label="Permalink to &quot;画像をエビデンスとして貼るべきかどうか&quot;">​</a></h3><p><a href="https://github.blog/changelog/2023-05-09-more-secure-private-attachments/" target="_blank" rel="noreferrer">2023年5月9日のアップデート</a>で、プライベートリポジトリのプルリクエストなどにアップロードされたファイルの閲覧に、認証が必須となった（それまではURLを知っていれば無認証でアクセスができてしまっていた）。</p><p>推奨は以下の通り。</p><ul><li>フロントエンドなど画面開発の場合は、作成／修正後の画像（必要に応じてGIF動画）を貼ることを推奨する</li><li>スタックトレースなどは、検索性を考えてテキストで貼ることを推奨する</li></ul><div class="info custom-block"><p class="custom-block-title">参考</p><p>GIF動画を作成するには、以下の記事で紹介されているツールの利用者も多い。</p><ul><li><a href="https://future-architect.github.io/articles/20220107a/#ScreenToGif" target="_blank" rel="noreferrer">Future社員が使っているWindows便利ツール（新人さん向け） | フューチャー技術ブログ</a></li></ul></div><h3 id="files-changedで余計なファイルがコミットされていないか確認する" tabindex="-1">Files changedで余計なファイルがコミットされていないか確認する <a class="header-anchor" href="#files-changedで余計なファイルがコミットされていないか確認する" aria-label="Permalink to &quot;Files changedで余計なファイルがコミットされていないか確認する&quot;">​</a></h3><p>ジュニアメンバー／シニアメンバー問わず、特に新規参画した当初は新しい環境に慣れるのに手一杯で、誤った操作をしがちである。よくあるミスには、余分なファイルをコミットに含めてしまうことや、誤ったブランチからブランチを作成してしまったため、余計な差分が発生してしまうことなどがある。</p><p>推奨は以下の通り。</p><ul><li>レビュー依頼前に、プルリクエスト画面の <code>Files changed</code> タブを開き、対象のファイルが想定通りか確認する</li></ul><p>このように、 <code>Files changed</code> を見ると、ローカルのエディタで見るのとは違ったセルフレビューの効果があるため、レビュアーになった気持ちで変更内容を確認することも推奨する。</p><h3 id="files-changedで特に見て欲しいポイントを補足する" tabindex="-1">Files changedで特に見て欲しいポイントを補足する <a class="header-anchor" href="#files-changedで特に見て欲しいポイントを補足する" aria-label="Permalink to &quot;Files changedで特に見て欲しいポイントを補足する&quot;">​</a></h3><p>プルリクエストで、特に念入りに確認して欲しいポイントや、リファクタリングなど複数のコミットが混ざり、メインの改修ポイントがわかりにくくなってしまう場合がある。後者はコミットごとにレビューすれば解決するケースもあるが、featureブランチはスカッシュマージするチームでは、必ずしもきれいなコミットを求めないケースも多い。</p><p>推奨は以下の通り。</p><ul><li>特に注力してレビューして欲しいポイントがあれば、<code>Files changed</code> でセルフコメントを付ける</li></ul><div class="warning custom-block"><p class="custom-block-title">セルフコメントが非推奨の場合</p><ul><li>意図がわかりにくい実装の補足や、背景情報などは、プルリクエスト上のコメントではなく、設計ドキュメントや、コードコメントに記載する。それにより保守運用性を高めることができる</li><li>「PJの実装ガイドライン・ルールから敢えて外れる実装を選択している」場合は、コードコメントに記載すべきである</li></ul><p>意図や背景情報をレビュアーに強調したい場合は、コードコメントに対して「実装意図はコードコメントに記載」などセルフコメントすると良い。</p></div><h3 id="assigneesは自分を設定する" tabindex="-1">Assigneesは自分を設定する <a class="header-anchor" href="#assigneesは自分を設定する" aria-label="Permalink to &quot;Assigneesは自分を設定する&quot;">​</a></h3><p>プルリクエストのAssigneesは基本的にはレビュイー本人にする。もし、作成したプルリクエストを別の担当者に引き継ぐときは、Assigneesも変更する。これにより、最終的にどの開発者がどのような作業をしたか可視化しやすくなる。</p><p>Assigneesで指定された人が、そのプルリクエストの責任を持つ。つまり、マージさせるかクローズさせるか最終的に意思決定されるよう、推進する必要がある。</p><h3 id="reviewers設定はレビュー依頼時にブランクで良い" tabindex="-1">Reviewers設定はレビュー依頼時にブランクで良い <a class="header-anchor" href="#reviewers設定はレビュー依頼時にブランクで良い" aria-label="Permalink to &quot;Reviewers設定はレビュー依頼時にブランクで良い&quot;">​</a></h3><p>Reviewersに設定することで、レビュアーが自身のアサインに気が付きやすくするメリットや、後からどれくらいレビューしたか把握しやすくできる。</p><p>推奨は以下の通り。</p><ul><li>レビュアーが確定している場合は、レビュー依頼時に予め必要な数のReviewersに設定しておく</li><li>チームのだれがレビューするか不明な場合は、ブランクにする（候補者を片っ端からReviewersに設定しない）</li><li>CODEOWNERSで指定したファイルを編集したなどで、自明であればオーナーをReviewersに追加しておく</li></ul><h3 id="ciの成功を確認する" tabindex="-1">CIの成功を確認する <a class="header-anchor" href="#ciの成功を確認する" aria-label="Permalink to &quot;CIの成功を確認する&quot;">​</a></h3><p>ローカルでLinterやテストが通っていると、プルリクエスト作成後、すぐにレビュー依頼を行いたくなる。しかし、何かしらの理由でレビュアーが確認した際にCIによるチェックが失敗している場面もよく見る。</p><p>推奨は以下の通り。</p><ul><li>レビュー依頼を出す前にCIが通っていることを確認する</li></ul><p>理由は以下。</p><ul><li>レビュアーとして、最初のフィードバックは「CIが落ちているので修正して欲しい」となり、余計なやり取りのホップが発生するだけであるため</li></ul><h3 id="レビュー依頼時にurlを貼る" tabindex="-1">レビュー依頼時にURLを貼る <a class="header-anchor" href="#レビュー依頼時にurlを貼る" aria-label="Permalink to &quot;レビュー依頼時にURLを貼る&quot;">​</a></h3><p>プルリクエストのタイトルや、<code>#511</code> などの番号だけで依頼を出すのではなく、URLをSlackなどチャットに貼ることを推奨する。</p><p>理由は以下。</p><ul><li>齟齬を生じさせない依頼が可能となる</li><li>後々、該当のプルリクエストのURLでSlackなどチャット検索が可能とするため <ul><li>前提条件など、Slackのスレッド上で確認しているやり取りの有無を確認したい場面がある</li></ul></li></ul><h3 id="レビュー依頼はメンションを飛ばす" tabindex="-1">レビュー依頼はメンションを飛ばす <a class="header-anchor" href="#レビュー依頼はメンションを飛ばす" aria-label="Permalink to &quot;レビュー依頼はメンションを飛ばす&quot;">​</a></h3><p>コードレビュー待ちは他作業が捗らないことが多いし、別作業に移ったとしても集中したタイミングでレビューフィードバックがあり、集中が途切れることもしばしばある。</p><p>推奨は以下の通り。</p><ul><li>チャット上でのレビュー依頼はメンションを飛ばす <ul><li>なるべく早くレビューしてもらうことで、待機時間を最小化する</li><li>レビュー可能なタイミングの回答をもらい、別タスクに着手するかの計画に活かす</li></ul></li><li>メンションは、自チームが必要最小限所属する、Slackでいうユーザーグループを利用することが好ましい</li></ul><div class="tip custom-block"><p class="custom-block-title">レビュー反映後の連絡</p><p>レビュー対応が完了した場合も、再依頼が必要な場合はメンションを飛ばす方が良い。レビュアーとしても再度見て欲しいのかどうかは関心事であるためである。</p></div><h3 id="markdown記法を活用する" tabindex="-1">Markdown記法を活用する <a class="header-anchor" href="#markdown記法を活用する" aria-label="Permalink to &quot;Markdown記法を活用する&quot;">​</a></h3><p>Markdown記法を活用することで、Descriptionやレビューコメントを視覚的に整理し、意図を明確に伝えることを推奨する。</p><p>特に、見出しやコードブロックやリストを使用することで、よりわかりやすいコメントを提供する事ができる。</p><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://docs.github.com/ja/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax" target="_blank" rel="noreferrer">基本的な書き方とフォーマットの構文 - GitHub Docs</a></p></div><h3 id="マージはレビュイーが実施する" tabindex="-1">マージはレビュイーが実施する <a class="header-anchor" href="#マージはレビュイーが実施する" aria-label="Permalink to &quot;マージはレビュイーが実施する&quot;">​</a></h3><p><a href="/arch-guidelines/documents/forGitBranch/git_branch_standards.html#マージはだれが行うべきか">Gitブランチフロー規約</a>で記載された推奨ルールに従う。チームの自律性と生産性を重視するのであれば、レビュイーがマージすべきである。</p><p>信頼関係が構築できていれば、以下のようなやり取りが可能となり、スピード感が上がるためである。</p><ul><li>「コメントはしたけど承認（Approve）したので、随時対応してマージしてOKです」</li><li>「Conflictだけ対応したら、マージしちゃってください」</li></ul><p>何かしらの理由でレビュアーの関与度を増やす必要がある場合は、レビュアーがマージする。</p><div class="tip custom-block"><p class="custom-block-title">やり取りを減らすために、レビュアーが即マージする</p><p>typo修正など大したことがない修正であれば、やり取りを減らすためレビュアーが直接マージまで行った方が良い場面もある。</p></div><h2 id="レビュアーの推奨行動" tabindex="-1">レビュアーの推奨行動 <a class="header-anchor" href="#レビュアーの推奨行動" aria-label="Permalink to &quot;レビュアーの推奨行動&quot;">​</a></h2><h3 id="グラウンドルール" tabindex="-1">グラウンドルール <a class="header-anchor" href="#グラウンドルール" aria-label="Permalink to &quot;グラウンドルール&quot;">​</a></h3><p><strong>レビューはコミュニケーションである。コメント記載時には相手への敬意を忘れないこと。</strong></p><p>特にレビュアー側はその責務上、指摘コメントを多く行う役割であり、より一層の配慮（上下関係を作らないやりとり）が求められる。</p><p>レビューは作成者を詰問する場ではなく、より良いものをチーム一丸となって作るという考えが重要である。</p><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://tech.nri-net.com/entry/important_mindset_for_pull_requests" target="_blank" rel="noreferrer">プルリクエストを見る時、出す時に重要なマインドセット - NRIネットコムBlog</a></p></div><h3 id="レビュー依頼へのリアクションはできるだけ即レス" tabindex="-1">レビュー依頼へのリアクションはできるだけ即レス <a class="header-anchor" href="#レビュー依頼へのリアクションはできるだけ即レス" aria-label="Permalink to &quot;レビュー依頼へのリアクションはできるだけ即レス&quot;">​</a></h3><p>推奨は以下の通り。</p><ul><li>コードレビューの対応優先度を上げる</li><li>もし、利害関係者との会議中など、即座に対応することが難しい場合は、いつごろ確認するかのコメントを記載したり、代理でレビュー可能な人に依頼する</li></ul><p>理由は以下。</p><ul><li>レビュアーが気がついていないのか、気がついているが忙しくて対応できないかで、レビュイーがリマインドを送るかどうかの行動に影響があるため</li><li>レビュイーの作業見積もりに影響するため（レビュイーとして待機すべきか、他の作業を着手すべきか迷ったり、どれくらいで開発作業がクローズできそうかといった作業計画にも影響するため）</li></ul><div class="tip custom-block"><p class="custom-block-title">コードレビューの優先度を上げる</p><p>チーム開発において、レビュー待ちでの待機時間を最小化することでチームでの生産性を最大化できるとされる。</p><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://speakerdeck.com/okashoi/dousiteshou-wodong-kasuyorimotimunei-nokodorebiyuwoyou-xian-surubekinanoka" target="_blank" rel="noreferrer">どうして手を動かすよりもチーム内のコードレビューを優先するべきなのか - Speaker Deck</a></p></div></div><h3 id="reviewersを自分に設定する" tabindex="-1">Reviewersを自分に設定する <a class="header-anchor" href="#reviewersを自分に設定する" aria-label="Permalink to &quot;Reviewersを自分に設定する&quot;">​</a></h3><p>プルリクエストに対して、レビューを実際に行う場合はReviewersに自分を選択する。以下の理由がある。</p><ul><li>後からどのプルリクエストに対してレビューを実施したか、トレース／可視化しやすくする</li><li>他のレビュアーが、◯◯さんが見るなら終わってからレビューを行う／スキップするという判断材料を提供する</li></ul><h3 id="hotfixの場合はマージ先のブランチを確認する" tabindex="-1">hotfixの場合はマージ先のブランチを確認する <a class="header-anchor" href="#hotfixの場合はマージ先のブランチを確認する" aria-label="Permalink to &quot;hotfixの場合はマージ先のブランチを確認する&quot;">​</a></h3><p>通常のプルリクエストであれば、featureブランチはデフォルトブランチ（多くはdevelopブランチ）がデフォルトで選択されるため、間違えは少ない。一方でhotfixブランチの場合は、main、developの2ブランチにマージ先がありえるため間違えやすい。</p><p>特に慣れていないメンバーの場合は作業ミスも多発しやすいため、最初にマージ先のブランチが正しいか確認するクセを付けると良い。</p><div class="tip custom-block"><p class="custom-block-title">複数のdevelopブランチがある場合も間違えやすい</p><p>複数のリリースバージョンを並行して開発する場合、一時的に develop、develop2 と複数のアップストリームを保つ場合がある。このケースは特にマージ先を間違えやすいため注意する。</p></div><h3 id="「start-a-review」と「add-single-comment」の使い分け" tabindex="-1">「Start a review」と「Add single comment」の使い分け <a class="header-anchor" href="#「start-a-review」と「add-single-comment」の使い分け" aria-label="Permalink to &quot;「Start a review」と「Add single comment」の使い分け&quot;">​</a></h3><p>GitHubでのコードレビューは、<code>Start a review</code> を行うと <code>Submit review</code> しない限り、レビューコメントが自分以外のメンバーが参照できない。</p><p><code>Add single comment</code> の場合は投稿が即参照可能となる。</p><p>推奨は以下の通り。</p><ul><li>なるべく早くレビュイーにフィードバックを返すことを重視し、 <code>Add single comment</code> の利用を推奨する</li></ul><p>理由は以下。</p><ul><li>レビュイーとして、今レビューをしてもらっていると気付くことができ、心理的に楽になる</li><li>コメントを貰った部分の疑問点を即返信しレビュアーにフィードバックしたり、随時修正できる</li></ul><h3 id="レビュイーの思考を予想する" tabindex="-1">レビュイーの思考を予想する <a class="header-anchor" href="#レビュイーの思考を予想する" aria-label="Permalink to &quot;レビュイーの思考を予想する&quot;">​</a></h3><p>レビュアーは、レビュイーが気がついていないかもしれない観点や影響範囲を意識して見るべきである。</p><p>レビュイーの経験やスキルセットから、不足していると考えられる面を重点的に確認することで、レビューの質を上げることができる。</p><h3 id="暗黙知を形式知にする" tabindex="-1">暗黙知を形式知にする <a class="header-anchor" href="#暗黙知を形式知にする" aria-label="Permalink to &quot;暗黙知を形式知にする&quot;">​</a></h3><p>レビュー対象の変更内容が、機能上は問題なくても、他の実装方針と揺れている場合が存在する。</p><p>推奨は以下の通り。</p><ul><li>レビュイーに「機能上は問題ないが、保守性／可読性の観点から、他の設計方針に合わせてほしい」といった旨のフィードバックを行う</li><li>開発規約にその設計方針が未記載の場合は、レビュアーが追記する（Linterに追加できれば理想である）。追記内容のレビュアーに、先ほどのレビュイーを含めることが望ましい</li></ul><p>暗黙知を形式知にすることで、チームの方針が明文化され、透明性のある運営に繋げることができる。新規参画者にとってのオンボーディング負荷が下がり、戦力化が早まるメリットがある。</p><h3 id="レビューコメントにラベルを追加する" tabindex="-1">レビューコメントにラベルを追加する <a class="header-anchor" href="#レビューコメントにラベルを追加する" aria-label="Permalink to &quot;レビューコメントにラベルを追加する&quot;">​</a></h3><p>レビューコメントにはラベル（プレフィックス）をつけることを推奨する。レビューコメントの意図を明確にすることで、開発者間の非同期的なコミュニケーションを円滑にし、作業効率を向上させる。</p><p>以下にプレフィックスを利用した例を示す。</p><table tabindex="0"><thead><tr><th style="text-align:left;">プレフィクス</th><th style="text-align:left;">説明</th><th style="text-align:left;">例</th></tr></thead><tbody><tr><td style="text-align:left;">LGTM</td><td style="text-align:left;">Look Good To Me（良さげです）</td><td style="text-align:left;">[LGTM] 責務分解が明瞭で、良い実装です！💯</td></tr><tr><td style="text-align:left;">ASK</td><td style="text-align:left;">質問</td><td style="text-align:left;">[ASK] この実装意図が理解できず、どうして必要なのか教えてもらえますか❓️🤔</td></tr><tr><td style="text-align:left;">Q</td><td style="text-align:left;">ASKと同じ意味</td><td style="text-align:left;">[Q] 同上</td></tr><tr><td style="text-align:left;">MUST</td><td style="text-align:left;">必須</td><td style="text-align:left;">[MUST] ソート処理が漏れているため、順序が不正になってしまう可能性があります！</td></tr><tr><td style="text-align:left;">SHOULD</td><td style="text-align:left;">提案</td><td style="text-align:left;">[SHOULD] 愚直なループではなく、□□□の書き方の方が可読性および性能が良いです。書き換えを検討してください。</td></tr><tr><td style="text-align:left;">IMO</td><td style="text-align:left;">In My Opinion（自分ならこうしますが、どうでしょうか？）</td><td style="text-align:left;">[IMO] スコープの広さの割に変数名が短いため、 <code>name</code> ではなく <code>pre_ordered_product_name</code> などが良いかと思いました</td></tr><tr><td style="text-align:left;">NITS</td><td style="text-align:left;">Nitpick（枝葉ですが直して欲しい）</td><td style="text-align:left;">[NITS] この変数名は、単数形よりも複数形 <code>users</code> または <code>usersList</code> が適しているかと思います。</td></tr></tbody></table><p>それぞれの定義は以下。特に「ASK（Q）」と「MUST」はレビューコメントが解決しないと、プルリクエストの承認を行うべきではない。</p><table tabindex="0"><thead><tr><th style="text-align:left;">分類</th><th style="text-align:left;">プレフィクス</th><th style="text-align:left;">承認のために解決が必須</th><th style="text-align:left;">レビュイーの対応</th></tr></thead><tbody><tr><td style="text-align:left;">礼賛</td><td style="text-align:left;">LGTM</td><td style="text-align:left;"></td><td style="text-align:left;">リアクション不要</td></tr><tr><td style="text-align:left;">質問</td><td style="text-align:left;">ASK</td><td style="text-align:left;">✅️</td><td style="text-align:left;">回答が必須</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Q</td><td style="text-align:left;">✅️</td><td style="text-align:left;">同上</td></tr><tr><td style="text-align:left;">修正依頼</td><td style="text-align:left;">MUST</td><td style="text-align:left;">✅️</td><td style="text-align:left;">対応しない場合はコメントバックまたは、コード変更の対応が必須</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">SHOULD</td><td style="text-align:left;"></td><td style="text-align:left;">対応しない場合はコメントバックまたは、コード変更をできる限り実施する。対応見送りの場合は、チケット起票および、次リリースまでの対応が目安</td></tr><tr><td style="text-align:left;"><strong>提案</strong></td><td style="text-align:left;">IMO</td><td style="text-align:left;"></td><td style="text-align:left;">絵文字リアクションやコメントバックが推奨だが、対応の是非はレビュイーが判断する</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">NITS</td><td style="text-align:left;"></td><td style="text-align:left;">同上</td></tr></tbody></table><p>参考: <a href="https://techblog.lycorp.co.jp/ja/20241121icq" target="_blank" rel="noreferrer">コード品質向上のテクニック：第51回 確信的な質問 | LINEヤフー</a> にも、レビューアの「要求」であるのにもかかわらず、単なる「質問」にも読み取れてしまうミスコミュニケーションの例があり、 コードレビューにおいては要求と質問は明確に区別できるように書かれるべき とある。</p><h3 id="適度なユーモアを取り入れる" tabindex="-1">適度なユーモアを取り入れる <a class="header-anchor" href="#適度なユーモアを取り入れる" aria-label="Permalink to &quot;適度なユーモアを取り入れる&quot;">​</a></h3><p>心理的安全性を担保しつつレビューを楽しい場とするためには、ポジティブな絵文字（🚀✨️💯）を使うとともに、レビューコメントに適度にユーモアを入れると良い。</p><p>例えば、慣れない文化・チーム・技術スタックの中で成果を出していきたい新規参画者にとっては、どんなに論理的・建設的な内容であるレビュー指摘であっても、指摘が多いと精神的に辛くなってしまう傾向にある。そのため、何か良い点があればオーバーに褒めることや、ネガティブな内容であればちょっとしたジョークを入れることで、心理的安全性を上げていく必要がある。辛い場面であっても、辛い場面こそジョークで吹き飛ばしていけると良い。</p><p>以下に例を示す。</p><ul><li>「このチューニングが入ると操作性がチート並に爆速になって、お客様も喜んでくれそうですね🐆💨」</li><li>「さすがに年齢設定の上限が1000になっています。鶴は1000年生きると言いますが、ここは150までにしておきましょう🧝」</li></ul><div class="tip custom-block"><p class="custom-block-title">初マージはチーム全員で祝う</p><p>苦労すればするほど、初めてマージされる瞬間の喜びは大きいものである。基本的に新規参画者の初めてのマージはチーム全員で祝うと良い。</p><p><img src="`+o+'" alt=""></p></div><h3 id="指摘内容は具体的であればあるだけ良い" tabindex="-1">指摘内容は具体的であればあるだけ良い <a class="header-anchor" href="#指摘内容は具体的であればあるだけ良い" aria-label="Permalink to &quot;指摘内容は具体的であればあるだけ良い&quot;">​</a></h3><p>レビューコメントで「可読性が低いです」 といったコメントは、レビュイーが受け取るとどのように修正して良いか判断ができず、次のアクションに繋がりにくいため不毛である。そのため、面倒であっても、どのように直して欲しいか、できる限り具体的に指示する方が建設的である。</p><p>推奨は以下の通り。</p><ul><li>「可読性が低いです」 「{任意の非機能要件}を満たしていません」といったコメントで終始せず、具体的にどの部分を、どのように修正して欲しいかをフィードバックする</li><li>もし、修正する部分を（教育目的などで）レビュイーに考えてほしい場合は、その旨をコメントに追記する。レビュアーのお気持ちあてゲームにしないこと</li></ul><h3 id="指摘内容を論理的に説明できないのであれば、コメントすべきではない" tabindex="-1">指摘内容を論理的に説明できないのであれば、コメントすべきではない <a class="header-anchor" href="#指摘内容を論理的に説明できないのであれば、コメントすべきではない" aria-label="Permalink to &quot;指摘内容を論理的に説明できないのであれば、コメントすべきではない&quot;">​</a></h3><p>「なんとなく汚いです」は指摘ではない。悪いコードだと感じたのであれば、相手が納得できるように論理的に説明する。論理的に説明できないのであれば、指摘をすべきではない。</p><div class="info custom-block"><p class="custom-block-title">引用元</p><p><a href="https://www.slideshare.net/rootmoon/7-37892729" target="_blank" rel="noreferrer">デキるプログラマだけが知っているコードレビュー7つの秘訣 | PPT</a> p26</p></div><h3 id="出典があれば追記できるとベター" tabindex="-1">出典があれば追記できるとベター <a class="header-anchor" href="#出典があれば追記できるとベター" aria-label="Permalink to &quot;出典があれば追記できるとベター&quot;">​</a></h3><p>指摘内容の補足情報があれば追加するとベターである。例えば、「◯◯の観点で、このコードは△△の懸念があるため、□□□になるように修正をお願いします。公式ブログの{URL}にも記載があり、参考にできると思います。」といった形式である。</p><p>レビュイーが自分で調べれば事足りる場合もあるが、レビュアー側が出典を示すことで納得感が増す。また、誤った記事（過去のバージョンの記事や、見当違いの記事）を読んでしまい空回ってしまうことも、探す手間も減る。</p><h3 id="なるべく1度のレビューで指摘し切る" tabindex="-1">なるべく1度のレビューで指摘し切る <a class="header-anchor" href="#なるべく1度のレビューで指摘し切る" aria-label="Permalink to &quot;なるべく1度のレビューで指摘し切る&quot;">​</a></h3><p>レビュイーからすると、レビューの「依頼1→指摘1→対応1→確認依頼1→別の指摘2→対応2→確認依頼2→別の指摘3→…」と、依頼のたびに指摘をもらうとタスクの予実管理も作業見積もりも建てられずストレスである（ムービング・ゴールポストである）。</p><p>推奨は以下の通り。</p><ul><li>できるかぎり最初のレビューで、指摘事項を出し切る</li><li>もし、2回目以降のレビューで追加要素に気がついた場合は、「[imo] 1度目の指摘で見逃してしまってすいません。この部分ですが、～の観点のため修正してもらいたく。」などと非を認めつつ、コメントする</li></ul><h3 id="本筋から離れるコードコメントやreadmeのtypoなどはsuggestにする" tabindex="-1">本筋から離れるコードコメントやREADMEのtypoなどはsuggestにする <a class="header-anchor" href="#本筋から離れるコードコメントやreadmeのtypoなどはsuggestにする" aria-label="Permalink to &quot;本筋から離れるコードコメントやREADMEのtypoなどはsuggestにする&quot;">​</a></h3><p>プルリクエスト上のコメントで、レビュイーに対して直接変更内容を提案することができる<a href="https://docs.github.com/ja/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request" target="_blank" rel="noreferrer">Suggested changes</a>という機能がある。</p><p>推奨は以下の通り。</p><ul><li>可能であればできる限り、Suggested changes形式を利用する。特にtypo、ドキュメントの言い回しや表現の訂正は、直接的に変更を指示しないと、やり取りのホップ数が増える傾向にあり、非生産的である</li><li>新規参画者やジュニアメンバー向けに、教育目的で編集させたいと考える場合もあるが、何度かSuggested changesでフィードバックして直らなかったなど、限定的な場面で行う</li></ul><p>Suggested changesを使わないほうが良い場合もある。</p><ul><li>変数名のリネーム（一箇所だけ変更してもビルドエラーになり、その後のリファクタリングが余計に面倒であるため）</li><li>上記のリネームの例のように、リンターやテストに影響を与えるものは、レビューコメントという形でコメントする方が良い</li></ul><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://devblog.thebase.in/entry/2018/12/02/130657" target="_blank" rel="noreferrer">君は GitHub の Suggested change を知っているか？ - BASEプロダクトチームブログ</a></p></div><h3 id="nits-want以下-のコメントだけであれば、先にapproveする" tabindex="-1">nits（WANT以下）のコメントだけであれば、先にapproveする <a class="header-anchor" href="#nits-want以下-のコメントだけであれば、先にapproveする" aria-label="Permalink to &quot;nits（WANT以下）のコメントだけであれば、先にapproveする&quot;">​</a></h3><p>対応が必須ではない、いわゆるnitsな指摘事項だけの場合がある。</p><p>この場合の推奨は以下。</p><ul><li>さきにapproveしてから、「コメント部分を適時対応してマージして下さい」と伝える <ul><li>レビュイーの心理的負荷の軽減（レビュイーの裁量が増し信頼感が作れる）</li><li>余分なコミュニケーションが減り、スピード感が上がる</li></ul></li><li>先にapproveすることにより、nitsであるがその対応可否をまったく検討せず、セルフマージするようなメンバーがいた場合は、対応状況を見極めてからapproveしても良い <ul><li>つまり、初回、2回目は信頼してapproveすべきである</li></ul></li></ul><h3 id="レビュアーはローカル環境で動作確認をすべきか" tabindex="-1">レビュアーはローカル環境で動作確認をすべきか <a class="header-anchor" href="#レビュアーはローカル環境で動作確認をすべきか" aria-label="Permalink to &quot;レビュアーはローカル環境で動作確認をすべきか&quot;">​</a></h3><p>レビュー対象のリモートブランチを、ローカル環境にてテストなど動作確認すべきか迷う場合がある。レビュアーがローカルで動作検証を行うと、おそらく品質は高まるはずだが、レビュイーとの作業重複でもあるため工数は非常に高くなり、費用対効果は必ずしも良いと言えない。</p><p>推奨は以下の通り。</p><ul><li>レビュアーはローカル環境での動作確認はしなくても良い <ul><li>もちろん、しても良いがMUSTではない</li><li>CIで単体テストが成功／失敗しているかは確認できずはずである</li><li>どのように品質を担保するかはテスト戦略に依存させるべきである（その後のデプロイメント環境での結合テスト、システムテスト、性能テスト、障害テストなどに含まれるはずである）</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">動作確認はレビュイーにやってもらう</p><p>プルリクエスト作成ルールとして、CIで担保できる部分以外（例えばUIのスクリーンショットなど）は、 <a href="#画像をエビデンスとして貼るべきかどうか">画像をエビデンスとして貼るべきかどうか</a> なども参考にしつつ、レビュイーにエビデンスの添付を行ってもらうルールを考えるとよい。</p></div><h3 id="疑問点は臆せず質問する" tabindex="-1">疑問点は臆せず質問する <a class="header-anchor" href="#疑問点は臆せず質問する" aria-label="Permalink to &quot;疑問点は臆せず質問する&quot;">​</a></h3><p>レビュアーは意図が掴みきれない部分があった場合は、そのままにせず理解できるように務める必要がある。分かったふりをすると、後でその部分が火を噴くことが多いからである。また、「チーム全員が同じ知識を共有する」というコードレビューの意図からすると、レビュイーだけ分かっていればよいという状態は不健全である。レビュイーがリーダー（テックリード）であっても臆する必要はないし、レビュイーが自分より若手であったとしても、自分が調べても分からないことを聞くことは恥ではないので、堂々と教えてもらう。</p><p>推奨は以下の通り。</p><ul><li>不明点が少ない場合は、レビューコメントで質問する</li><li>不明点が多い場合は、同期的なコミュニケーション（リモート会議。SlackのハドルやGoogle Meet）で確認する。やり取りのホップ数をなるべく減らすことを意識する</li><li>リモート会議を行う場合は、レビュアー側から時間や枠を調整する</li></ul><h3 id="自信がない場合は、有識者にディスパッチする" tabindex="-1">自信がない場合は、有識者にディスパッチする <a class="header-anchor" href="#自信がない場合は、有識者にディスパッチする" aria-label="Permalink to &quot;自信がない場合は、有識者にディスパッチする&quot;">​</a></h3><p>レビュアーという立場だからといって、必ずしも開発チームが利用する全技術スタックや、開発プロダクトの過去の経緯に精通している訳ではない。それでも、自信が無い領域についてコードレビューを求められるケースも多々ある。</p><p>推奨は以下の通り。</p><ul><li>自分に自信がない領域については、レビュアーが無理せず有識者にディスパッチする体制にする <ul><li>分からないことは恥ではない。それより、知ったかぶりで手違いが発生する方がチームにとってのリスクである</li></ul></li><li>業務要件／機能要件が不明確であれば、プロダクトリーダー（業務担当者）に移譲する。非機能面で自信が無ければ、アーキテクトに移譲する。チーム規模によっては恒常的にこれら2つの役割のレビュアーで分担してレビュー方式も考えられる</li></ul><h3 id="ジュニアメンバーに対して大量の指摘がある場合にどうするか" tabindex="-1">ジュニアメンバーに対して大量の指摘がある場合にどうするか <a class="header-anchor" href="#ジュニアメンバーに対して大量の指摘がある場合にどうするか" aria-label="Permalink to &quot;ジュニアメンバーに対して大量の指摘がある場合にどうするか&quot;">​</a></h3><p>対象領域のスキル不足などが原因で、レビュー事項が大量にある場合に対応をどうすべきか迷う場合がある。</p><p>推奨は以下の通り。</p><ul><li>50でも100でも指摘事項があるのであれば、全てコメントを付ける <ul><li>最初に全量を提示することで、レビュイーに対して作業見積もりを可能とさせる。逆に最初にコメント領域を絞ると、ムービング・ゴールポストである</li><li>もし、作業負荷的に厳しい場合は同期コミュニケーションを入れることをためらわない</li></ul></li><li>指摘事項が多い場合、レビュイーが落胆してしまう懸念があるため、特に新規参画者で信頼構築ができていない場合は、コードレビューとは別にケアする <ul><li>指摘事項が多くても問題ない旨を、チャット上でフィードバックする</li><li>指摘事項の背景情報（開発規約や、採用技術）について説明する会議をセッテイングする（適度に同期的なコミュニケーションを取る）</li><li>ペアプロで指摘内容を修正する</li></ul></li><li>可能であれば、Suggested changesを用いて、レビュイーの負荷を下げる工夫を取る</li></ul><p>なお、類似の指摘がある場合に、省略するかどうか判断に迷う場面もある。これについては以下を推奨する。</p><ul><li>「ある1点だけ取り上げて、横展開をお願いします」は機能しないため、該当箇所を全てコメントする <ul><li>そのプルリクエスト内でレビュイーがキャッチアップしきれない可能性があるため、レビュアー側で補助した方がベター</li><li>横展開が漏れることが多く、余計なやり取りが発生し、レビュアー・レビュイーともにストレスになることが多いため</li></ul></li></ul><h3 id="レビュー終了の連絡" tabindex="-1">レビュー終了の連絡 <a class="header-anchor" href="#レビュー終了の連絡" aria-label="Permalink to &quot;レビュー終了の連絡&quot;">​</a></h3><p>レビュー終了した場合、レビューが終わった旨をプルリクエスト上でメンションをつけてコメントしたり、Slackなどのチャットで通知することで、レビュアーに対応を促すことができる。「Add single comment」の場合は、レビュー終了の切れ目が分からないためである。</p><p>推奨は以下の通り。</p><ul><li>Slackでのメンション付きでレビュー終了の旨のコメントする</li></ul><p>理由は以下。</p><ul><li>普段利用しているチャットツールの方がレビュイーの気づく確率が高いため</li></ul><h2 id="謝辞" tabindex="-1">謝辞 <a class="header-anchor" href="#謝辞" aria-label="Permalink to &quot;謝辞&quot;">​</a></h2><p>このアーキテクチャガイドラインの作成にあたり、多大なるご協力をいただきました皆様に心より感謝申し上げます。</p><ul><li><strong>作成者</strong>（真野隼記、村田靖拓、山本竜玄、清水雄一郎、水田祐介）</li><li><strong>レビュアー</strong>（谷村元気、栗田真、後藤玲雄、八木雅斗、辻大志郎）</li></ul><p>皆様のご尽力なしには、本ガイドラインの完成はなしえませんでした。改めて深く感謝いたします。</p>',232))])}const m=l(d,[["render",p]]);export{f as __pageData,m as default};
