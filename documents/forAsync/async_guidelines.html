<!DOCTYPE html>
<html lang="ja" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>非同期設計ガイドライン | フューチャー株式会社</title>
    
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/arch-guidelines/assets/style.vEtT7Kmu.css" as="style">
    <link rel="preload stylesheet" href="/arch-guidelines/vp-icons.css" as="style">
    
    <script type="module" src="/arch-guidelines/assets/app.CDOUd3Rc.js"></script>
    <link rel="preload" href="/arch-guidelines/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/framework.BIcz3et1.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/theme.osI3JgFR.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/katex.CBSAILhF.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/dagre-6UL2VRFP.DVx2T5rS.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/cose-bilkent-S5V4N54A.Dew--hOm.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/c4Diagram-YG6GDRKO.B2iDm8y3.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/flowDiagram-NV44I4VS.CYcfxykH.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/erDiagram-Q2GNP2WA.B-utUa05.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/gitGraphDiagram-NY62KEGX.N33VuG3b.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/ganttDiagram-JELNMOA3.FEMyrN_y.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/infoDiagram-WHAUD3N6.DEOX_qZ3.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/pieDiagram-ADFJNKIX.BUspq7vV.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/quadrantDiagram-AYHSOK5B.B6L7vq59.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/xychartDiagram-PRI3JC2R.CRanKAbk.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/requirementDiagram-UZGBJVZJ.Dtkra5kl.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/sequenceDiagram-WL72ISMW.Bdhpd5wP.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/classDiagram-2ON5EDUG.Dy9cgSNo.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/classDiagram-v2-WZHVMYZB.Dy9cgSNo.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/stateDiagram-FKZM4ZOC.Cy28hei0.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/stateDiagram-v2-4FDKWEC3.IkcS1WSQ.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/journeyDiagram-XKPGCS4Q.DxH1srne.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/timeline-definition-IT6M3QCI.C8eINXpR.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/mindmap-definition-VGOIOE7T.3mrOnPrM.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/kanban-definition-3W4ZIXB7.CYqHlJm4.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/sankeyDiagram-TZEHDZUN.Ch4Xt8C4.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/diagram-S2PKOQOG.JW5mE2oh.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/diagram-QEK2KX5R.CCm4bGgS.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/blockDiagram-VD42YOAC.BCUmDelw.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/architectureDiagram-VXUJARFQ.B712ks8f.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/diagram-PSM6KHXK.CnNOjpOR.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/arch-guidelines/assets/documents_forAsync_async_guidelines.md.D0I6SR9o.lean.js">
    <link rel="icon" href="/arch-guidelines/favicon.ico" sizes="any">
    <link rel="icon" href="/arch-guidelines/images/logo-system.svg" type="image/svg+xml">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="ja_JP">
    <meta property="og:site_name" content="アーキテクチャ設計ガイドライン | フューチャー株式会社">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
    <meta name="keywords" content="Async,SQS">
    <meta property="og:title" content="非同期設計ガイドライン">
    <meta property="og:description" content="非同期処理特有の「本質的な難しさ」をどう乗り越えるか。安易な非同期化を防ぐ判断基準、トランザクションアウトボックスによる整合性担保、DLQを用いたリカバリ運用など、現場で使える設計論点とベストプラクティスを網羅的に解説します。">
    <meta name="description" content="非同期処理特有の「本質的な難しさ」をどう乗り越えるか。安易な非同期化を防ぐ判断基準、トランザクションアウトボックスによる整合性担保、DLQを用いたリカバリ運用など、現場で使える設計論点とベストプラクティスを網羅的に解説します。">
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-fcbfc0e0></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-fcbfc0e0>Skip to content</a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/arch-guidelines/" data-v-9f43907a><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/arch-guidelines/images/logo-dark.svg" alt data-v-ab19afbb><!--]--><!--[--><img class="VPImage light logo" src="/arch-guidelines/images/logo.svg" alt data-v-ab19afbb><!--]--><!--]--><!--]--><span data-v-9f43907a>Future <wbr>Architecture Guidelines</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-afb2845e data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-bfe7971f><span class="text" data-v-bfe7971f><!----><span data-v-bfe7971f>Guidelines</span><span class="vpi-chevron-down text-icon" data-v-bfe7971f></span></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><div class="items" data-v-20ed86d6><!--[--><!--[--><div class="VPMenuGroup" data-v-20ed86d6 data-v-a6b0397c><p class="title" data-v-a6b0397c>アプリケーション</p><!--[--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forWebFrontend/web_frontend_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Web フロントエンド</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forWebAPI/web_api_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Web API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link active" href="/arch-guidelines/documents/forAsync/async_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>非同期</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forBatch/batch_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>バッチ</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forIF/if_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>I/F</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forMail/mail_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>メール</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forLog/log_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>ログ</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-20ed86d6 data-v-a6b0397c><p class="title" data-v-a6b0397c>DB</p><!--[--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forDB/postgresql_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>PostgreSQL</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forDB/dynamodb_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>DynamoDB</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forDataManagement/datamanagement_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>データマネジメント</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-20ed86d6 data-v-a6b0397c><p class="title" data-v-a6b0397c>インフラ</p><!--[--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forAWS/aws_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>AWS</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forTerraform/terraform_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Terraform</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-20ed86d6 data-v-a6b0397c><p class="title" data-v-a6b0397c>開発生産性</p><!--[--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forGitBranch/git_branch_standards.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Gitブランチフロー</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forMarkdown/markdown_design_document.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Markdown設計ドキュメント</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forCodeReview/code_review.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>コードレビュー</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forSlack/slack_usage_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Slack利用</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-20ed86d6 data-v-a6b0397c><p class="title" data-v-a6b0397c>その他</p><!--[--><!--[--><div class="VPMenuLink" data-v-a6b0397c data-v-7eeeb2dc><a class="VPLink link" href="/arch-guidelines/documents/forSoftSkill/softskill_guidelines.html" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>ソフトスキル</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-afb2845e data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-bfe7971f><span class="text" data-v-bfe7971f><!----><span data-v-bfe7971f>About Us</span><span class="vpi-chevron-down text-icon" data-v-bfe7971f></span></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><div class="items" data-v-20ed86d6><!--[--><!--[--><div class="VPMenuLink" data-v-20ed86d6 data-v-7eeeb2dc><a class="VPLink link vp-external-link-icon" href="https://www.future.co.jp/" target="_blank" rel="noreferrer" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>フューチャー株式会社</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-20ed86d6 data-v-7eeeb2dc><a class="VPLink link vp-external-link-icon" href="https://future-architect.github.io/" target="_blank" rel="noreferrer" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Blog</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-20ed86d6 data-v-7eeeb2dc><a class="VPLink link vp-external-link-icon" href="https://qiita.com/organizations/future" target="_blank" rel="noreferrer" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Qiita</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-20ed86d6 data-v-7eeeb2dc><a class="VPLink link vp-external-link-icon" href="https://twitter.com/future_techblog" target="_blank" rel="noreferrer" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>X</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-20ed86d6 data-v-7eeeb2dc><a class="VPLink link vp-external-link-icon" href="https://www.facebook.com/future.saiyo/" target="_blank" rel="noreferrer" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Facebook</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-20ed86d6 data-v-7eeeb2dc><a class="VPLink link vp-external-link-icon" href="mailto:techblog@future.co.jp" target="_blank" rel="noreferrer" data-v-7eeeb2dc><!--[--><span data-v-7eeeb2dc>Email <techblog@future.co.jp></span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/future-architect/arch-guidelines" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/future-architect/arch-guidelines" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-6b867909><button data-v-6b867909>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 has-active" data-v-51288d80 data-v-0009425e><!----><div class="items" data-v-0009425e><!--[--><div class="VPSidebarItem level-1 is-link" data-v-0009425e data-v-0009425e><div class="item" data-v-0009425e><div class="indicator" data-v-0009425e></div><a class="VPLink link link" href="/arch-guidelines/documents/forAsync/" data-v-0009425e><!--[--><p class="text" data-v-0009425e>Introduction</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0009425e data-v-0009425e><div class="item" data-v-0009425e><div class="indicator" data-v-0009425e></div><a class="VPLink link link" href="/arch-guidelines/documents/forAsync/async_guidelines.html" data-v-0009425e><!--[--><p class="text" data-v-0009425e>非同期設計ガイドライン</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>On this page</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _arch-guidelines_documents_forAsync_async_guidelines" data-v-e6f2a212><div><div class="vitepress-page-title" data-v-9bab9843><div class="share-buttons" data-v-9bab9843><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-url="https://future-architect.github.io/arch-guidelines/documents/forAsync/async_guidelines.html" data-show-count="false" data-v-9bab9843> Tweet </a><div class="fb-like" data-href="https://future-architect.github.io/arch-guidelines/documents/forAsync/async_guidelines.html" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="true" data-v-9bab9843></div><a href="http://b.hatena.ne.jp/entry/s/future-architect.github.io/arch-guidelines/documents/forAsync/async_guidelines.html" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加" data-v-9bab9843><img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border:none;" data-v-9bab9843></a><div href="https://github.com/future-architect/arch-guidelines" data-icon="octicon-star" data-show-count="true" aria-label="Star future-architect/arch-guidelines on GitHub" data-v-9bab9843> Star </div><a href="https://getpocket.com/save" class="pocket-btn" data-lang="en" data-save-url="https://future-architect.github.io/arch-guidelines/documents/forAsync/async_guidelines.html" data-pocket-count="horizontal" data-pocket-align="left" data-v-9bab9843>Pocket</a></div><h1 class="vitepress-page-title__title" data-v-9bab9843>非同期設計ガイドライン</h1><div class="vitepress-page-title__author" data-v-9bab9843>フューチャー株式会社</div></div><div class="warning custom-block"><p class="custom-block-title">免責事項</p><ul><li>有志で作成したドキュメントである。フューチャーには多様なプロジェクトが存在し、それぞれの状況に合わせて工夫された開発プロセスや高度な開発支援環境が存在する。本ガイドラインはフューチャーの全ての部署／プロジェクトで適用されているわけではなく、有志が観点を持ち寄って新たに整理したものである</li><li>相容れない部分があればその領域を書き換えて利用することを想定している。プロジェクト固有の背景や要件への配慮は、ガイドライン利用者が最終的に判断すること。本ガイドラインに必ず従うことは求めておらず、設計案の提示と、それらの評価観点を利用者に提供することを主目的としている</li><li>掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとする。掲載している情報は予告なく変更する場合がある</li></ul></div><h2 id="はじめに" tabindex="-1">はじめに <a class="header-anchor" href="#はじめに" aria-label="Permalink to &quot;はじめに&quot;">​</a></h2><p>かつて、非同期処理は専門的なメッセージングミドルウェアを必要とする、一部のミッションクリティカルなシステムで採用される特別な技術と言えた。今やクラウドネイティブなサービス（例：AWS SQSなど）の登場で状況は様変わりし、応答時間の長い処理のオフロードなどを目的に、非同期処理を取り入れることは珍しくない。一方で、非同期特有の難しさは変わらず、「処理のトレース」 「デバッグ」 「リラン」が困難であり、データストアにまたがる場合のデータの整合性担保や障害発生時のリカバリは難易度が高い。</p><p>本ガイドラインは、非同期導入時のメリットを享受しつつ、「本質的な難しさ」を回避または適切に管理するための実務的な設計論点と指針を提供する。堅牢で運用しやすい非同期システムを設計するための一助になれば幸いである。</p><h2 id="適用範囲" tabindex="-1">適用範囲 <a class="header-anchor" href="#適用範囲" aria-label="Permalink to &quot;適用範囲&quot;">​</a></h2><p>本ガイドラインが対象とするスコープは、バックエンドシステムにおける以下のような非同期メッセージングを用いた処理に限る。</p><ul><li>Web APIやバッチ処理からのトリガーによる非同期メッセージやキューと、その後のコンシューマー処理</li><li>ストリーミング処理は関連する領域であるが、タイムウィンドウなど特有の処理については深くは触れない</li></ul><p>以下は含まれない。</p><ul><li>各プログラミング言語で準備されている非同期処理の実装方法。例えばJavaScriptでのasync/await、Javaでのスレッド/仮想スレッド、Goのgoroutineなどには触れない</li><li>ブラウザのサービスワーカー</li></ul><h2 id="用語" tabindex="-1">用語 <a class="header-anchor" href="#用語" aria-label="Permalink to &quot;用語&quot;">​</a></h2><p>非同期処理には、メッセージキューのサービスを利用する。そうした種別や、プロダクトごとに呼び名が様々存在する。</p><table tabindex="0"><thead><tr><th style="text-align:left;">分類</th><th style="text-align:left;">キュー</th><th style="text-align:left;">Pub/Sub</th><th style="text-align:left;">ストリーミング</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">1:1型。1つのメッセージが1つの受信者に処理される。メッセージは処理後に削除</td><td style="text-align:left;">1:N型。1つのメッセージを複数のワーカーが受け取る。メッセージは処理後に削除</td><td style="text-align:left;">1:N型。複数のワーカーが異なる読み取り位置から再生可能。メッセージは指定期間、永続化</td></tr><tr><td style="text-align:left;">具体例</td><td style="text-align:left;">SQS, RabbitMQ</td><td style="text-align:left;">SNS、MQTT</td><td style="text-align:left;">Kafka、Kinesis</td></tr><tr><td style="text-align:left;">送信者</td><td style="text-align:left;">プロデューサー</td><td style="text-align:left;">パブリッシャー</td><td style="text-align:left;">プロデューサー</td></tr><tr><td style="text-align:left;">受信者</td><td style="text-align:left;">コンシューマー</td><td style="text-align:left;">サブスクライバー</td><td style="text-align:left;">コンシューマー</td></tr><tr><td style="text-align:left;">メッセージ格納場所</td><td style="text-align:left;">キュー</td><td style="text-align:left;">トピック</td><td style="text-align:left;">トピック/ストリーム</td></tr><tr><td style="text-align:left;">データ単位</td><td style="text-align:left;">メッセージ</td><td style="text-align:left;">メッセージ/Notification/イベント</td><td style="text-align:left;">レコード/イベント</td></tr><tr><td style="text-align:left;">順序性保証/グループ化</td><td style="text-align:left;">Message Group ID (SQS FIFOキューの場合)</td><td style="text-align:left;">-</td><td style="text-align:left;">パーティション</td></tr><tr><td style="text-align:left;">読み取り位置</td><td style="text-align:left;">Visibility Timeout</td><td style="text-align:left;">-</td><td style="text-align:left;">オフセット/シーケンス番号</td></tr></tbody></table><p>上表のように非同期処理で利用される技術や製品によって用語は様々であるが、本ガイドラインでは、一貫性を保つために以下の用語を使用する。</p><div class="mermaid"></div><ul><li><strong>プロデューサー:</strong> メッセージの送信側のコンポーネント</li><li><strong>コンシューマー:</strong> メッセージを受信して処理するコンポーネント</li><li><strong>メッセージ:</strong> プロデューサーとコンシューマー間でやり取りされるデータの単位</li><li><strong>キュー</strong>: メッセージを中継するサービス</li></ul><h2 id="非同期化の判断基準" tabindex="-1">非同期化の判断基準 <a class="header-anchor" href="#非同期化の判断基準" aria-label="Permalink to &quot;非同期化の判断基準&quot;">​</a></h2><p>非同期処理は同期処理と比較して処理のトレースやデバッグの難易度が上がり、運用・保守コストは増大する。そのため、安易に導入するのではなく必要最低限の範囲で検討することが重要である。</p><p>ある処理を非同期化するかどうかは、次の観点と検討フローで判断する。</p><div class="mermaid"></div><h3 id="処理時間と応答性" tabindex="-1">処理時間と応答性 <a class="header-anchor" href="#処理時間と応答性" aria-label="Permalink to &quot;処理時間と応答性&quot;">​</a></h3><p>ある処理の処理時間が長く、呼び出し元が同期的な応答を待つことができない場合は非同期化を検討する。</p><p>例えば、ファイルのダウンロードの要求を受け付けてからダウンロードファイルを長時間生成する場合が該当する。同期的に生成するとエンドユーザーを待たせるため UX が低下する恐れがある。この場合、メッセージをキューに登録し呼び出し元には即時応答を返す。ファイルの生成処理は非同期処理として裏側で行い、処理完了後に呼び出し元へ通知することで、UX を最適化できる。</p><p>なお、応答時間の長い処理が呼ばれることは業務上限定的であり、呼ばれた場合に業務運用上の工夫で応答時間の長さが許容できる場合は、非同期化は不要と判断もできる。</p><h3 id="負荷の平準化" tabindex="-1">負荷の平準化 <a class="header-anchor" href="#負荷の平準化" aria-label="Permalink to &quot;負荷の平準化&quot;">​</a></h3><p>ある処理が突発的に、大量に呼び出される可能性がある場合、負荷を時間的に分散するために非同期化を検討する。この場合、メッセージをキューに登録し実処理は非同期処理として裏側で行うことで、バーストによる負荷を平準化しつつスループットを最適化できる。</p><p>なお、バーストの規模と時期が予測でき、事前のリソース増強で運用上対応できる場合は、非同期化は不要と判断もできる。</p><h3 id="レジリエンスの向上" tabindex="-1">レジリエンスの向上 <a class="header-anchor" href="#レジリエンスの向上" aria-label="Permalink to &quot;レジリエンスの向上&quot;">​</a></h3><p>ある処理が、外部のシステムや複数のデータストアに依存している場合に、依存している部分の処理をメインの処理とは独立して切り離せる場合は、非同期化を検討する。</p><p>例えば、あるメイン処理の終了処理として、外部システムの Web API 呼び出し、処理結果を通知する場合が該当する。このようなケースでは Web API 呼び出しを非同期化することで、外部システムがダウンしていたとしてもメインの処理を継続させ、システムの継続性を高めることができる。</p><p>またDBにあるデータを登録した後、オブジェクトストレージにもデータを登録するケースなども該当する。どちらかの処理が失敗した場合にデータが不整合な状態で残り続ける（どちらか一方にしかデータが存在しない）ことを許容できない場合は、キューを介してデータストアへの書き込みを直列化し、非同期処理側で適切なリトライを行うことで、結果的なデータの整合性を担保できる。</p><p>なお、「外部システムダウン時に、メイン処理自体がエラー終了すること」を許容でき、かつ「失敗したデータのリカバリを手動やバッチ等で行う運用コスト」が見合う場合は、非同期化による複雑さを避け、同期処理を選択することも合理的である。</p><h2 id="同期・非同期の使い分け" tabindex="-1">同期・非同期の使い分け <a class="header-anchor" href="#同期・非同期の使い分け" aria-label="Permalink to &quot;同期・非同期の使い分け&quot;">​</a></h2><p><a href="#非同期化の判断基準">前章</a> の判断基準で述べた通り、非同期処理はシステム全体の複雑性を上げる。逆に言うと可能な限り同期処理に寄せることで開発性・運用性を高めることができる。</p><p>しかし、この「同期によるシンプルさ」を過信し、本来分離すべき処理まで同期的に実行すると、障害を引き起こす可能性がある。</p><h3 id="ケーススタディ-同期処理による保険申込みの障害" tabindex="-1">ケーススタディ：同期処理による保険申込みの障害 <a class="header-anchor" href="#ケーススタディ-同期処理による保険申込みの障害" aria-label="Permalink to &quot;ケーススタディ：同期処理による保険申込みの障害&quot;">​</a></h3><p>保険申し込みのコールセンターを例に説明する（※説明のため架空の設定である）。入電した電話を同期的にオペレーターに振り分けるシステムが稼働していた。</p><ol><li>オペレーターへの電話の振り分け</li><li>通話録音データの暗号化</li><li>通話記録レポートのDB保存</li></ol><p>平常時は問題なかったが、入電が集中するキャンペーンのピークタイムにおいて、2の遅延が重なりWebサーバーのリソースが枯渇した。結果として、本来最優先すべき1の処理までがタイムアウトし、電話が一切受け付けられなくなるという障害に発展する。この障害は、2, 3を非同期化していれば、防ぐことができたはずである。</p><p>例が示すように、非同期化の判断ポイントは 「非機能要件定義」における「将来想定」での「ピーク時のアクセス数」から導き出せる「スループット」と「負荷の平準化」である。この時、通話データの暗号化やDB保存といった重い処理が、要件を満たすことができるかをまず机上で仮説を立てるべき（同期で大丈夫 or 非同期化が必要）である。その上で、<a href="#負荷テスト">負荷テスト</a> にあるように、実機検証し、性能を担保する。</p><h2 id="非同期から非同期の呼び出し" tabindex="-1">非同期から非同期の呼び出し <a class="header-anchor" href="#非同期から非同期の呼び出し" aria-label="Permalink to &quot;非同期から非同期の呼び出し&quot;">​</a></h2><p>コンシューマーが、その処理の一部として、さらに別の非同期処理を呼び出すと、非同期処理が連鎖する。主なモチベーションに以下がある。</p><ul><li><strong>並列化による性能改善</strong>: 親タスクから多数の子タスクを並列実行することで性能を向上させる</li><li><strong>リカバリ単位の分割</strong>: 一連の長いビジネスプロセスを、複数の独立したトランザクションに分割し、障害時の影響範囲を限定、リカバリしやすくする</li><li><strong>外部システム連携</strong>: 非同期処理の途中で、応答に時間のかかる外部APIなどを呼び出し、メインの非同期処理への影響を局所化する</li></ul><p>このトレードオフとして、処理のトレーシングや障害発生時の原因特定をさらに複雑化させる要因となり得る。</p><p>推奨は以下の通り。</p><ul><li>同期処理から非同期処理を呼び出す時と同じく、入れ子となる非同期処理の採用も必要最小限に留める <ul><li>非同期処理が連鎖する程、開発効率やトレーサビリティは低下する傾向があるため</li><li>以下の目的で非同期の連鎖を検討している場合は、代替手段で解決できないか再考する（オーバーエンジニアリングの可能性があるため） <ul><li><strong>流量制御が目的の場合:</strong>: 後続処理を守るためにキューを分けてクッションにするのではなく、<a href="#流量制御">流量制御</a> の章にある通り、コンシューマー自体の同時実行数やスループット制限（Lambdaの予約済み同時実行数など）で制御できないか検討する。構成要素が増えるほど運用コストが増大するため、設定値での解決を優先する</li><li><strong>データ整合性が目的の場合（外部API連携など）</strong>: 外部API呼び出しの成功結果を記録するためだけに非同期を分けるのではなく、同一コンシューマー内で「API呼び出し → 成功後に自DBコミット」という一連の流れで完結できないか検討する。トランザクション管理が単一で済むのであれば、その方が整合性担保の難易度は低い</li></ul></li></ul></li><li>非同期から非同期を呼び出す基準としては、<strong>前段と後続でイベント処理の粒度が変わるケース</strong>は許容する <ul><li><strong>呼び出し元より粒度が「大きく」なるケース（集約）</strong><ul><li><strong>（例）ECサイト：</strong> 注文（同期）→ 在庫引当（非同期1）→ <strong>倉庫内のピッキング指示（非同期2）</strong></li><li><strong>理由：</strong> 引当の都度ピッキング指示を出すより、一定数近隣のロケーションからのピッキングが溜まった時点でまとめて指示をする方が効率的なため。ただし、この場合は別プロセスでポーリングさせピッキングが溜まった時点での指示を第一に考える</li></ul></li><li><strong>呼び出し元より粒度が「細かく」なるケース（分散）</strong><ul><li><strong>（例）月次決済：</strong> 締め処理（同期）→ 請求額計算（非同期1）→ <strong>個々のユーザ決済実行（非同期2）</strong></li><li><strong>理由：</strong> 複数のユーザーに対する決済処理を「非同期1」の中で順次ループ処理すると、1件の失敗や遅延が全体の完了を遅らせるリスクがあるため、個別に分割して実行する</li></ul></li></ul></li></ul><p>判断フローの例を示す。</p><div class="mermaid"></div><h2 id="バッチから非同期呼び出し" tabindex="-1">バッチから非同期呼び出し <a class="header-anchor" href="#バッチから非同期呼び出し" aria-label="Permalink to &quot;バッチから非同期呼び出し&quot;">​</a></h2><p>非同期処理の呼び出しは、ユーザーの操作イベント経由だけではなく、バッチ処理から呼びだされる場合もありえる。<a href="https://future-architect.github.io/arch-guidelines/documents/forBatch/batch_guidelines.html#%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%BF%E3%82%B9%E3%82%AF" target="_blank" rel="noreferrer">バッチ設計ガイドライン</a> を参照すること。</p><h2 id="キュー環境" tabindex="-1">キュー環境 <a class="header-anchor" href="#キュー環境" aria-label="Permalink to &quot;キュー環境&quot;">​</a></h2><p>非同期処理に利用するキューの実行環境は以下の3パターンの方式がある。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）フルマネージド</th><th style="text-align:left;">（2）マネージドランタイム</th><th style="text-align:left;">（3）セルフホスト</th></tr></thead><tbody><tr><td style="text-align:left;">例</td><td style="text-align:left;">Amazon SQS / Cloud Pub/Sub / Azure Service Bus</td><td style="text-align:left;">Amazon MQ / Azure Service BusのAMQP1.0互換</td><td style="text-align:left;">RabbitMQまたはApache ActiveMQをECSやEC2にデプロイ</td></tr><tr><td style="text-align:left;">分類</td><td style="text-align:left;">プロプライエタリ</td><td style="text-align:left;">オープンソース/標準プロトコル互換</td><td style="text-align:left;">オープンソース（ミドルウェア）</td></tr><tr><td style="text-align:left;">AMQP互換</td><td style="text-align:left;">なし</td><td style="text-align:left;">あり</td><td style="text-align:left;">あり</td></tr><tr><td style="text-align:left;">可用性・拡張性</td><td style="text-align:left;">✅️高い</td><td style="text-align:left;">✅️高い</td><td style="text-align:left;">⚠️実装依存</td></tr><tr><td style="text-align:left;">設計コスト</td><td style="text-align:left;">✅️低い</td><td style="text-align:left;">⚠️やや高い</td><td style="text-align:left;">❌️高い</td></tr><tr><td style="text-align:left;">運用コスト</td><td style="text-align:left;">✅️インスタンス管理等が不要で使用に応じた課金</td><td style="text-align:left;">❌️インスタンスの管理が必要となり起動中は課金が発生</td><td style="text-align:left;">❌️インスタンスの管理が必要となり起動中は課金が発生</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（1）を推奨する</li><li>以下の場合は（2）または（3）を採用するケースもある <ul><li>オンプレミスまたはマルチクラウド環境に構築する場合</li><li>ベンダーロックインを回避すべき要件がある場合</li><li>既に存在するRabbitMQまたはActiveMQのサーバーをクラウドシフトする場合</li></ul></li></ul><p>選定フローのイメージは以下の通り。</p><div class="mermaid"></div><h2 id="プロトコル" tabindex="-1">プロトコル <a class="header-anchor" href="#プロトコル" aria-label="Permalink to &quot;プロトコル&quot;">​</a></h2><p>現代のクラウド環境における非同期設計では、AMQP (Advanced Message Queuing Protocol) や MQTT (Message Queuing Telemetry Transport) といった古典的なメッセージングプロトコルそのものを開発者が直接意識する場面は稀である。</p><p>AWS SQSやSNSは、AWS SDKを介した HTTPS APIコールによって操作されるため、プロトコルレベルの詳細は抽象化されている。AMQP、MQTT、Kafkaプロトコルなどを選択するかどうかは、どのプロトコルを使用するかどうかではなく、どのメッセージングプロダクトの選定をするかに等しい。そのため、プロトコル選定は本ガイドラインでは設計上の論点として取り扱わない。</p><h2 id="非同期処理の論理構成方針" tabindex="-1">非同期処理の論理構成方針 <a class="header-anchor" href="#非同期処理の論理構成方針" aria-label="Permalink to &quot;非同期処理の論理構成方針&quot;">​</a></h2><p>スケーラビリティや保守性および障害分離の観点から、各コンポーネント（プロデューサー、キュー、コンシューマー）の分割単位および論理的な配置に関する標準方針を定めることが重要となる。</p><p>推奨は以下の通り。</p><ul><li>1業務タスク = 1キュー = 1コンシューマー(Lambda関数) とする <ul><li>メッセージングキューは「1つのイベントタイプ（業務処理単位）につき、1つのキュー」で定義する</li><li>コンシューマーも同様にイベントタイプ（業務処理単位）で実装して、複数の業務処理を混在させないようにする</li></ul></li></ul><p><strong>理由：</strong></p><ul><li>障害分離: 複数の異なる業務（例: メール送信と決済処理）を1つのキューに混在させると、片方の障害や遅延がもう片方に影響するため。また、エラー時にどの業務が失敗したかの切り分けが困難になる</li><li>スケーリング: コンシューマー（Lambda）ごとに「予約済み同時実行数」などのリソース制限を設けることで、業務の優先度に応じた<a href="#流量制御">流量調整</a>（スロットリング）が可能になる</li><li>排他制御・重複排除: 1つのキューで扱うメッセージのスキーマを特定の項目または複合項目で一意に設計することができて適切なステータス管理が実装可能になる</li></ul><p>複数のプロデューサーから1つのメッセージングキューに対して同じスキーマ構造を持つメッセージを送信することは問題ないが、その場合は特に順序制御や重複排除に留意して設計する必要がある。 また、メッセージをファンアウトさせる場合、プロデューサーから直接複数のキューにメッセージに送信するのではなく、SNSを経由させる。</p><ol><li>1対1のシンプル構成：<code>Producer (Lambda)</code> -&gt; <code>SQS</code> -&gt; <code>Consumer (Lambda)</code><ul><li>単純な高負荷処理の非同期オフロードなど、将来的にも他の業務処理が同じメッセージを利用する可能性が低い場合</li><li>例：帳票（PDF）の生成処理や外部SaaSへのデータ連携処理</li></ul></li><li>1対Nのファンアウト構成：<code>Producer (Lambda)</code> -&gt; <code>SNS Topic</code> -&gt; <code>SQS A / B</code> -&gt; <code>Consumer (Lambda) A / B</code><ul><li>同一のメッセージを複数の業務処理で消費する場合やコンシューマーの機能追加など拡張性を重視する場合</li><li>例：「注文確定イベント」に対して「在庫引当」だけでなく「分析基盤への通知」を追加するケース</li></ul></li></ol><h2 id="qos" tabindex="-1">QoS <a class="header-anchor" href="#qos" aria-label="Permalink to &quot;QoS&quot;">​</a></h2><p>キューにおけるQoS（Quality of Service）とは、以下の3レベルで表現される。なお、すべてのレベルで順序保証がされるわけではない。</p><table tabindex="0"><thead><tr><th style="text-align:left;">レベル</th><th style="text-align:left;">説明</th><th style="text-align:left;">リスク</th></tr></thead><tbody><tr><td style="text-align:left;">At most once</td><td style="text-align:left;">メッセージが1回以下（0回または1回）送信されること</td><td style="text-align:left;">❌️メッセージ欠損がありえる</td></tr><tr><td style="text-align:left;">At least once</td><td style="text-align:left;">メッセージが少なくとも1回は送信されること</td><td style="text-align:left;">❌️コンシューマーが2回以上重複して起動されることがありえる</td></tr><tr><td style="text-align:left;">Exactly once</td><td style="text-align:left;">メッセージがちょうど1回送信されること</td><td style="text-align:left;">✅️メッセージの受け渡しは1回であるが、送信側が2重で送信した場合に重複排除されるわけではない</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>QoSを選択できる場合、欠損がありえるため At most onceを利用しない</li><li>少なくとも、At least once以上のレベルを用いる。費用観点で、At least onceを選択することを最初の選択肢とする</li><li>QoSに関わらず、タスクは冪等に作る（At least onceでは重複起動がありえる。Exactly onceであっても、ジョブのリカバリなどで重複して起動されることはありえるため）</li></ul><h2 id="postgresqlやredisのpub-sub機能を用いた非同期" tabindex="-1">PostgreSQLやRedisのPub/Sub機能を用いた非同期 <a class="header-anchor" href="#postgresqlやredisのpub-sub機能を用いた非同期" aria-label="Permalink to &quot;PostgreSQLやRedisのPub/Sub機能を用いた非同期&quot;">​</a></h2><p>PostgreSQLの <code>NOTIFY/LISTEN</code> やRedisの <code>PUBLISH/SUBSCRIBE</code> は、DBやキャッシュサーバーにがすでに存在している場合、SQSなどが追加のインフラ構築なしで非同期化を実現できるため軽量な非同期通信の仕組みとして魅力的に映る。注意として、これらの機能はメッセージの永続性が存在しないという点がある。例えば、コンシューマーが何らかのプロセス障害か、ネットワーク切断の間に発行されたメッセージは、キューに保持されない。復旧時にも再取得ができない。そのため、コンシューマー側を冗長構成にしておき、ステータス管理テーブルなどを用いた排他制御を行い重複排除する必要がある。</p><table tabindex="0"><thead><tr><th style="text-align:left;">比較観点</th><th style="text-align:left;">SQS</th><th style="text-align:left;">PostgreSQL</th><th style="text-align:left;">Redis</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">ガイドライン推奨の方式</td><td style="text-align:left;">PostgreSQLのNOTIFY/LISTENを用いる方式</td><td style="text-align:left;">RedisのPUBLISH/SUBSCRIBEを用いる方式</td></tr><tr><td style="text-align:left;">配信保証</td><td style="text-align:left;">✅️At-Least-Once (最低1回)</td><td style="text-align:left;">⚠️At-Most-Once (最大1回)</td><td style="text-align:left;">⚠️At-Most-Once (最大1回)</td></tr><tr><td style="text-align:left;">メッセージ永続性</td><td style="text-align:left;">✅ あり (最大14日間)</td><td style="text-align:left;">❌ なし。コンシューマー停止時メッセージ欠損の懸念</td><td style="text-align:left;">❌ なし。コンシューマー停止時メッセージ欠損の懸念</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>業務ロジックの非同期実行は「確実に処理される」必要があり、この実行基盤に PostgreSQL NOTIFY/LISTEN および Redis PUBLISH/SUBSCRIBE は使用しない <ul><li>特にRedisは通常、コストが高くこれに依存するメリットは小さいため</li><li>PostgreSQLのPub/Subについて、Amazon RDSにおいてリードレプリカで利用できない制約があるなど、拡張性での懸念もある</li></ul></li><li>ただし、PostgreSQL Pub/Subを用いた実行フレームワークやサービスなど、内部で用いておりそれらの品質が保証されている場合はその限りではない。非推奨というのは、直接これらの機能をSQSの代わりに利用することを指している</li></ul><div class="tip custom-block"><p class="custom-block-title">Redis Streams</p><p>RedisにはPUBLISH/SUBSCRIBE（揮発性）とは別に、Streamsという永続的な（Kafkaに似た）データ構造が存在する。これを利用すれば永続的なキューも可能である。</p><ul><li><a href="https://redis.io/docs/latest/develop/data-types/streams/" target="_blank" rel="noreferrer">Redis Streams | Docs</a></li></ul></div><h2 id="順序保障" tabindex="-1">順序保障 <a class="header-anchor" href="#順序保障" aria-label="Permalink to &quot;順序保障&quot;">​</a></h2><p>多くの標準的なキュー（AWS SQS の標準キューなど）は、スループットを最大化するためにメッセージの処理順序を「ベストエフォート」としており、厳密な順序を保証していない。しかし、非同期処理においてメッセージ処理の順序保証が必要となった場合は設計方式を検討する必要がある。</p><p>順序制御に関する設計方式は以下の2パターンがある。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）FIFOキューの利用</th><th style="text-align:left;">（2）アプリケーション側での制御 (標準キュー利用)</th></tr></thead><tbody><tr><td style="text-align:left;">概要</td><td style="text-align:left;">キュー自体がメッセージの順序を保証 (例: AWS SQS FIFOキュー)</td><td style="text-align:left;">標準キューを使い、メッセージにシーケンス番号等を付与して、コンシューマー側で順序を判定・制御</td></tr><tr><td style="text-align:left;">順序の厳密性</td><td style="text-align:left;">✅️高い</td><td style="text-align:left;">⚠️実装に依存</td></tr><tr><td style="text-align:left;">スケーラビリティ</td><td style="text-align:left;">✅️高い</td><td style="text-align:left;">❌️低い</td></tr><tr><td style="text-align:left;">スループット</td><td style="text-align:left;">✅️高い（標準キューより低いが、適切なメッセージグループ定義ができていればアプリケーションの実装より高くなる）</td><td style="text-align:left;">⚠️実装に依存 （キュー自体はFIFOキューと比較して高いが、アプリケーション側の実装によって低くなる可能性が高い）</td></tr><tr><td style="text-align:left;">設計コスト</td><td style="text-align:left;">✅️低い （メッセージグループなど制御単位の設計は必要）</td><td style="text-align:left;">❌️非常に複雑となる</td></tr><tr><td style="text-align:left;">運用コスト</td><td style="text-align:left;">✅️標準キューと比べてやや高い<br>（ただし、AWS SQSの場合は数千万リクエスト/月程度でないと影響はない）</td><td style="text-align:left;">⚠️実装に依存</td></tr><tr><td style="text-align:left;">制約</td><td style="text-align:left;">サービスやミドルウェアがFIFOに対応している必要がある</td><td style="text-align:left;">実装次第であり制約は特にない</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>原則として、可能な限り順序制御を必要としない設計（冪等性の確保や、メッセージの独立性）を目指す</li><li>「厳密な順序保証が必要な場合」は（1）を採用する <ul><li>SQS FIFOを採用する場合、MessageGroupId（論理的な順序制御グループ）の設計がスループットの鍵であることを認識し、順序保証が必要な最小単位でグループ化すること</li><li>MessageGroupId は原則として 「順序が必要な一連の処理（トランザクション）単位での ID」 を設定すること <ul><li>✅️**（推奨）：** コンシューマーで取り扱うビジネスエンティティID（OrderID, UserID, AccountID など）</li><li>❌️**（非推奨）：** 固定値（完全直列化）、ランダム値、粒度が粗すぎるID（Head-of-Line (HOL) ブロッキングのリスク大）</li></ul></li></ul></li><li>（2）は「FIFOキューが利用不可能なレガシー環境かつアプリケーション処理上で冪等性が担保できない場合」でなければ非推奨とする</li><li>復旧可能性の「ある」エラーへの対応は <a href="#リトライ">リトライ</a> 章の通りコンシューマー側で対応する</li></ul><p>復旧可能性の「ない」エラーへの対応について、<strong>SQS FIFOで厳密な順序保証が必要な場合はDLQを使用してはならない</strong>。 FIFOキューでDLQを利用すると、エラーメッセージがDLQに移動した時点で、後続のメッセージのロックが解除され処理が開始される。つまり、エラーとなった処理がスキップされた状態で後続が動くため、業務上の厳密な順序性が崩れることになる。</p><p>復旧可能性の「ない」エラーへの対応については、以下の2つの戦略が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">設計案</th><th style="text-align:left;">（1）エラーが発生したら即時停止 + 手動介入</th><th style="text-align:left;">（2）エラーが発生したメッセージをスキップ</th></tr></thead><tbody><tr><td style="text-align:left;">概要</td><td style="text-align:left;">永続的エラーと判断したら即時アラートして、運用にてリカバリ対応を行う</td><td style="text-align:left;">エラーが発生したメッセージは諦める（別途リカバリする）が、後続の正常なメッセージの処理は止めない</td></tr><tr><td style="text-align:left;">処理方式</td><td style="text-align:left;">・コンシューマー側は永続的なエラーと判断した時点でエラー通知する<br> ・運用側はアラート通知を受けて復旧させる（メッセージはDLQに移動させず、削除もしないのでリカバリが終わるまでコンシューマー側で異常終了が継続することになる）</td><td style="text-align:left;">・コンシューマー側は永続的なエラーと判断したメッセージの内容をデータベースやログなどに保存して、DLQに送信する<br>・後続メッセージの処理が再開される。DLQは適切にリカバリする</td></tr><tr><td style="text-align:left;">順序の厳密性</td><td style="text-align:left;">あり</td><td style="text-align:left;">なし</td></tr><tr><td style="text-align:left;">可用性・スループット</td><td style="text-align:left;">❌️低い</td><td style="text-align:left;">✅️高い</td></tr><tr><td style="text-align:left;">運用コスト</td><td style="text-align:left;">❌️非常に高い</td><td style="text-align:left;">✅️比較して低い</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（2）を選択できるよう、結果整合性を業務要件として調整する</li><li>業務要件上、厳格な順序制御が必要となるケースでは（1）での対応が必須となる <ul><li>この場合、何か1つでもエラーになるとそれ以降の処理がブロッキングされるため、早期のリカバリが求められる。運用負荷は非常に高くなるためできる限り緩和できないか考える</li></ul></li></ul><div class="info custom-block"><p class="custom-block-title">参考</p><p><a href="https://docs.aws.amazon.com/ja_jp/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" target="_blank" rel="noreferrer">Amazon SQS でのデッドレターキューの使用</a> に、「メッセージまたは操作の正確な順序を維持する必要がある場合は、FIFOキューでデッドレターキューを使用しないでください」とある。</p></div><h2 id="重複排除と冪等性" tabindex="-1">重複排除と冪等性 <a class="header-anchor" href="#重複排除と冪等性" aria-label="Permalink to &quot;重複排除と冪等性&quot;">​</a></h2><p>原則として、メッセージを受信するコンシューマーの処理は冪等にすることを推奨する。キューが重複排除の仕組みを持っている場合は積極的に利用すべきであるが、プロデューサー側での送信処理の重複などを考慮すると完全な重複排除できないものとして考えるべきである。</p><p>SQSを利用する場合の重複排除（Exactly once）の仕組みには以下の選択肢がある。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）FIFOキュー</th><th style="text-align:left;">（2）標準キュー + 冪等コンシューマー</th></tr></thead><tbody><tr><td style="text-align:left;">仕組み</td><td style="text-align:left;">「メッセージ重複排除ID」または「コンテンツベースの重複排除」の利用</td><td style="text-align:left;">コンシューマー側での重複チェック処理などの実装</td></tr><tr><td style="text-align:left;">重複排除の主体</td><td style="text-align:left;">SQS</td><td style="text-align:left;">コンシューマー</td></tr><tr><td style="text-align:left;">重複排除期間</td><td style="text-align:left;">5分間</td><td style="text-align:left;">永続的</td></tr><tr><td style="text-align:left;">スループット</td><td style="text-align:left;">✅️高い（標準キューには劣る）</td><td style="text-align:left;">✅️非常に高い</td></tr><tr><td style="text-align:left;">構築コスト</td><td style="text-align:left;">✅️低い（キューのオプションまたは送信時のID付与のみ）</td><td style="text-align:left;">⚠️実装次第（冪等性を担保するロジックが必要）</td></tr><tr><td style="text-align:left;">費用</td><td style="text-align:left;">✅️標準キューと比べてやや高い<br>（ただし、AWS SQSの場合は数千万リクエスト/月程度でないと影響はない）</td><td style="text-align:left;">✅️低い</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>原則、（1）を採用する。FIFOキュー利用によるクラウド利用費用の増加は多くのケースで誤差レベルであると考えられるため</li><li>スループットが重視されるケース（数千～数万TPS）や<a href="https://docs.aws.amazon.com/ja_jp/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html" target="_blank" rel="noreferrer">SQS FIFOキューの重複排除ウィンドウである5分間</a>を超える必要があるケースは（2）を採用する</li></ul><h2 id="リトライ" tabindex="-1">リトライ <a class="header-anchor" href="#リトライ" aria-label="Permalink to &quot;リトライ&quot;">​</a></h2><p>メッセージ処理がエラーで失敗した場合に、処理を再試行するための戦略は次の通り。</p><p><strong>復旧可能性のあるエラーへの対応</strong>:</p><ul><li>外部Web APIの呼び出し時のタイムアウトなど、一時的な障害で復旧が見込まれる場合は、リトライ戦略（回数や間隔）を定めて再試行する</li><li>一般的に、リトライ回数を重ねるごとに間隔を長くするエクスポネンシャルバックオフなどの戦略が有効である。採用するメッセージングサービスやプロダクトがエクスポネンシャルバックオフをサポートしている場合は、利用することを推奨する。SQSを採用する場合、リトライ間隔はVisibility Timeoutでの制御となり、エクスポネンシャルバックオフを実現する場合は、処理ロジックの中でタイムアウト値を都度制御（ChangeMessageVisibility）しなければならない。そのため実装コストに見合う効果が得られると判断できる場合のみ、エクスポネンシャルバックオフを採用することとする。</li></ul><p><strong>復旧可能性のないエラーへの対応</strong>:</p><ul><li>内部ロジックのエラーやメッセージそのもののバリデーションエラーなど、何度リトライしても成功しないエラーの場合は、無駄なリソース消費やシステム全体への影響を防ぐために、リトライを打ち切ってメッセージをDLQに移動させる。</li></ul><h2 id="メッセージロックのタイムアウト" tabindex="-1">メッセージロックのタイムアウト <a class="header-anchor" href="#メッセージロックのタイムアウト" aria-label="Permalink to &quot;メッセージロックのタイムアウト&quot;">​</a></h2><p>メッセージロックのタイムアウトとは、キューにおいてコンシューマーがメッセージを取得し処理している間、そのメッセージを他のコンシューマーから見えなくし重複処理を防ぐための時間制限のことである。Amazon SQSでは、このメッセージロックのタイムアウトを「Visibility Timeout：可視性タイムアウト」と呼ぶ。</p><p>設定の主体:</p><ul><li>本設定は、キューの定義またはコンシューマー側で行う。プロデューサーの指定は不可</li><li>キュー定義: キュー作成時にデフォルト値として指定できる。Lambdaを利用する場合、受信時のタイムアウト値はこのキュー設定値に固定される</li><li>コンシューマー側: メッセージ受信時（<code>ReceiveMessage</code>）に動的にタイムアウト値を指定できる。処理中にAPI（<code>ChangeMessageVisibility</code>）を呼び出して延長もできる。Lambdaの場合は <code>ChangeMessageVisibility</code> でのみタイムアウト値を変えることになる</li></ul><p>タイムアウト設定のトレードオフ:</p><ul><li><strong>短すぎる場合:</strong> メッセージの処理中にタイムアウトを迎えた場合、他のコンシューマーが同じメッセージを取得して処理を開始してしまうため、処理が重複して実行されてしまう</li><li><strong>長すぎる場合:</strong> メッセージの処理中に、一時的なエラー（ネットワークエラーなど）が発生した場合などは、コンシューマーは処理を中断し、メッセージをキューに戻すことでリトライを試みることが一般的である。タイムアウト値が長いと、この再試行が許可されるまでの時間が長くなるため、リカバリまでの時間が長くなり、メッセージが滞留することで全体のスループットが低下する</li></ul><p>推奨は以下の通り。</p><ul><li>根本的にメッセージの処理時間を厳密に予測することは難しいため、処理が重複起動しても問題ないよう、冪等な設計を大前提とする</li><li>個々の処理ごとにタイムアウト値をきめ細かく最適化したいケースは稀であるため、システムとして基準となるタイムアウト値（例：SQSのデフォルト30秒）を定め、その値では明らかに問題となる処理のみを個別にチューニングするアプローチを推奨する</li><li>タイムアウト値は、メッセージの最大処理時間を算出した上で、一定の安全マージンを加算した値を初期値とすることが望ましい</li><li>メッセージによって処理時間に極端なばらつきがある（特定のメッセージのみ処理時間が非常に長い）など処理時間が予測できない場合は、処理中に一定間隔（例：タイムアウト値の半分）でキューサービスに対し「ロック時間の延長」をリクエスト（例：SQSの<code>ChangeMessageVisibility</code>）するハートビート機構の導入を検討する</li><li>冪等な設計が困難であり、ビジネス影響上万が一にも重複起動が許容できない場合は、タイムアウト値へ達する前に処理をロールバックする強制的なキャンセル機構を導入するか、前述のハートビート機構の導入を検討する</li></ul><div class="tip custom-block"><p class="custom-block-title">Lambdaの場合、可視性タイムアウトを関数タイムアウトの6倍に設定すべきか？</p><p>AWSドキュメントで、<a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-lambda-function-trigger.html" target="_blank" rel="noreferrer">可視性タイムアウトを関数タイムアウトの6倍以上にすべきと推奨</a>されている。この数値の論拠は、Lambdaの起動が何かしらの理由でスロットリングされた場合、内部で関数タイムアウトx5回+αの時間枠でリトライされるためである。 しかし、本ガイドラインではステータス管理テーブルで重複排除する思想であるため、この可視性タイムアウトでの制御のみに厳密に拘る必要はない。そのため、推奨にある通りシステムとして基準となるタイムアウト値を設定し、あまりに重複起動が多く発生すると考えられる場合に、個別チューニングする方針とする。</p></div><h2 id="メッセージ送信の信頼性" tabindex="-1">メッセージ送信の信頼性 <a class="header-anchor" href="#メッセージ送信の信頼性" aria-label="Permalink to &quot;メッセージ送信の信頼性&quot;">​</a></h2><p>プロデューサー側で自領域のDB更新とキューへのメッセージ送信の整合性をどのように保つかが課題となる。例えば、キューの送信には成功したが自領域のDBのコミットに失敗してしまうことが考えられる。この場合、コンシューマーは起動するが処理対象のデータが存在しないため不整合となる。これはファントムメッセージと呼ばれる。</p><div class="mermaid"></div><p>これは、単純に順序を逆転しても解決しない。むしろ、一部処理が成功したと見せかけて後続のコンシューマーが起動しないというメッセージロストが発生する分、事態は悪化しているとも言える。</p><div class="mermaid"></div><p>代表的な対応案にトランザクションアウトボックスパターンがある。</p><div class="info custom-block"><p class="custom-block-title">トランザクションアウトボックスパターン</p><ol><li>各コンシューマーは自身の担う業務ロジック処理と、処理完了を示すステータス更新を1トランザクションで実施する。</li><li>後続コンシューマーへのメッセージ連携は、別のトランザクションで行う。</li></ol><p>これにより、1→2の順序性の担保と、2単体でのリトライが可能となる。</p></div><p>ファントムメッセージが発生する直接ディスパッチ方式と、トランザクションアウトボックスパターンのポーリング版、CDC版を下表で比較する。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）直接ディスパッチ</th><th style="text-align:left;">（2）アウトボックス (ポーリング・リレー)</th><th style="text-align:left;">（3）アウトボックス (CDC・リレー)</th></tr></thead><tbody><tr><td style="text-align:left;">図</td><td style="text-align:left;"><img src="/arch-guidelines/assets/direct_dispatch.drawio.DoGIikrv.png" alt="DBとキューへ両方アクセス"></td><td style="text-align:left;"><img src="/arch-guidelines/assets/outbox_polling.drawio.BcUasYBo.png" alt="別プロセスがDBポーリングしてキューにメッセージ送信"></td><td style="text-align:left;"><img src="/arch-guidelines/assets/outbox_eventdriven.drawio.DRvO7Scn.png" alt="CDC経由でLambdaを起動しキューへメッセージ送信"></td></tr><tr><td style="text-align:left;">処理概要</td><td style="text-align:left;">メッセージ送信 → DBコミット</td><td style="text-align:left;">DBコミット → (別プロセス) → ポーリング → メッセージ送信</td><td style="text-align:left;">DBコミット → (CDC) → イベント → メッセージ送信</td></tr><tr><td style="text-align:left;">信頼性</td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">クラッシュ時の主なリスク</td><td style="text-align:left;">❌ファントムメッセージの懸念</td><td style="text-align:left;">✅ リレーの送信失敗時は、次回のポーリングで自動リトライされる</td><td style="text-align:left;">✅ リレーのリトライCDCがトリガーしたLambda等のリトライ機構で処理される</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">✅ 低</td><td style="text-align:left;">⚠️中 ポーリングバッチの実装/運用が必要</td><td style="text-align:left;">❌ 高 CDCパイプライン(Debezium/DMS等)の構築/運用が必要</td></tr><tr><td style="text-align:left;">レイテンシ</td><td style="text-align:left;">✅ 低</td><td style="text-align:left;">⚠️ 中～高（ポーリング間隔に依存）</td><td style="text-align:left;">✅ 低</td></tr><tr><td style="text-align:left;">DB負荷</td><td style="text-align:left;">✅ 低</td><td style="text-align:left;">⚠️ 中（定期的なポーリングスキャンが発生）</td><td style="text-align:left;">✅ 低（トランザクションログベース）</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（1）を採用する <ul><li>ファントムメッセージについては、<a href="#ステータス管理テーブル">ステータス管理テーブル</a> をプロデューサー側が登録＋コンシューマー側でレコードチェックすれば不正検知ができるため。ステータス管理テーブルを用意しない場合は、(2)のような仕組みの導入を検討する</li></ul></li><li>（2）は実行順序を保証し柔軟に制御する必要がある場合に採用を検討する。(3)は仕組みが重厚になりすぎるため非推奨とする</li></ul><h2 id="非同期処理ステータス設計" tabindex="-1">非同期処理ステータス設計 <a class="header-anchor" href="#非同期処理ステータス設計" aria-label="Permalink to &quot;非同期処理ステータス設計&quot;">​</a></h2><p>非同期処理は実行状況をログなどから追うことはたいへんであるため、キューにメッセージを送受信する前後で、DBにステータス管理テーブルを作成し、書き込む方式にすると運用上の利便性が高まる。</p><h3 id="ステータス管理テーブル" tabindex="-1">ステータス管理テーブル <a class="header-anchor" href="#ステータス管理テーブル" aria-label="Permalink to &quot;ステータス管理テーブル&quot;">​</a></h3><p>ステータス管理テーブルには、プロデューサーがキューへの送信前とコンシューマーが終了時にアクセスすることで、進捗状況を明らかにできる。これにより、保守運用者が、DB検索から非同期タスクの実行状況を把握できる。</p><p>一般的な設計事項は以下の通り。</p><ul><li>コンシューマーが処理開始時にステータステーブルを確認し、ジョブIDが実行中か処理済みになっていないかチェックする <ul><li>もし、未処理、実行中、異常終了などのステータスのレコードが無ければ、INFO/WARNログを出して正常終了させる</li><li>あるいは、ロックが取れなければ、多重実行されたとして自処理はINFOログをだして正常終了させる</li></ul></li><li>コンシューマーが異常終了時は、通常業務テーブルはロールバックすることが自然であるため、ステータス管理テーブルの値をFAILEDにする場合は、自律型トランザクションでコミットさせる必要がある</li></ul><div class="mermaid"></div><p>推奨は以下の通り。</p><ul><li>非同期の処理ステータス管理テーブルを作成し、DBで状況を把握できるようにする</li><li>プロデューサー、コンシューマーがキューの前後で適切にこれらを処理する</li><li>キーとなるジョブIDはトレースIDとは通常、別に採番する <ul><li>非同期が連鎖した場合には、一意制約になるため</li><li>トレースIDは紐づけ用に、ステータス管理テーブルの属性に持たせる</li></ul></li><li>RUNNINGを自律型トランザクションでコミットする必要はない。実装が楽な行ロックを推奨する</li></ul><h3 id="命名規則" tabindex="-1">命名規則 <a class="header-anchor" href="#命名規則" aria-label="Permalink to &quot;命名規則&quot;">​</a></h3><p>各ステータスの区分値についての方針を決めておくと、複数のシステムを横断的に保守運用する際の認知負荷を下げることができる。</p><p>主要なバッチ処理系での表現は下表である。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">AWS Batch</th><th style="text-align:left;">Google Cloud Batch</th><th style="text-align:left;">Azure Batch</th><th style="text-align:left;">Hitachi JP1</th><th style="text-align:left;">Spring Batch</th></tr></thead><tbody><tr><td style="text-align:left;">先行タスク・リソース待機</td><td style="text-align:left;">SUBMITTED</td><td style="text-align:left;">PENDING</td><td style="text-align:left;">Active</td><td style="text-align:left;">開始時刻待ち, 先行終了待ち</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;">実行可能</td><td style="text-align:left;">RUNNABLE</td><td style="text-align:left;">ASSIGNED</td><td style="text-align:left;">Preparing</td><td style="text-align:left;">キューイング</td><td style="text-align:left;">STARTING</td></tr><tr><td style="text-align:left;">実行中</td><td style="text-align:left;">STARTING, RUNNING</td><td style="text-align:left;">RUNNING</td><td style="text-align:left;">Running</td><td style="text-align:left;">実行中</td><td style="text-align:left;">STARTED</td></tr><tr><td style="text-align:left;">成功/完了</td><td style="text-align:left;">SUCCEEDED</td><td style="text-align:left;">SUCCEEDED</td><td style="text-align:left;">Completed</td><td style="text-align:left;">正常終了</td><td style="text-align:left;">COMPLETED</td></tr><tr><td style="text-align:left;">失敗/エラー</td><td style="text-align:left;">FAILED</td><td style="text-align:left;">FAILED</td><td style="text-align:left;">Completed</td><td style="text-align:left;">異常終了</td><td style="text-align:left;">FAILED</td></tr><tr><td style="text-align:left;">停止/キャンセル</td><td style="text-align:left;">-</td><td style="text-align:left;">(UNEXECUTED)</td><td style="text-align:left;">-</td><td style="text-align:left;">強制終了</td><td style="text-align:left;">STOPPED</td></tr><tr><td style="text-align:left;">保留/中断</td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">保留中</td><td style="text-align:left;">-</td></tr></tbody></table><p>主要な区分値の遷移図は以下。</p><div class="mermaid"></div><p>推奨は以下の通り。</p><ul><li>ステータスの命名規則を定め、一貫して利用する</li><li>特にこだわりがなければ、Google Cloud Batchの語彙（PENDING、RUNNING、SUCCEEDED、FAILEDなど）を用いる <ul><li>比較的、簡易な単語で構成されており、またよく見ている並びによる見間違え（STARTING, STARTEDなど）が無いため</li></ul></li><li>設計変更でステータスをSUCCEEDED1, SUCCEEDED2 のように増やしたくなる場合は、処理自体を分割したほうがよい</li><li>保留/中断は先行処理の待機を除いて、非同期処理それ自体が保留となるステータスは作らない <ul><li>重複排除と冪等性 及び 順序制御 を前提に、呼び出し側で処理の実施有無をコントロールすべきであるため</li></ul></li></ul><h2 id="予約" tabindex="-1">予約 <a class="header-anchor" href="#予約" aria-label="Permalink to &quot;予約&quot;">​</a></h2><p>特定の時刻に非同期処理を開始したいという需要がある。このためプロデューサーがメッセージを即時キューに入れるのではなく、適切なタイミングまで待機させる設計が必要となる場合がある。</p><p>例えば、以下のようなユースケースが考えられる。</p><ul><li>メールなどの予約送信（Slackのようなチャットツールへの予約投稿（チャットサービス側に予約機能が無い想定）</li></ul><p>このスケジューリングの責務をどこに持たせるかで以下の2パターンが考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">設計案</th><th style="text-align:left;">（1）外部スケジューラー</th><th style="text-align:left;">（2）ステータス管理テーブルのポーリング</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">毎日N時実行、毎月M日実行など、特定の日時や条件が決まっている定期バッチを、各クラウドプロバイダが提供するサービスをはじめ、各製品に備わっている予約機能を用いて非同期処理を開始する。</td><td style="text-align:left;">特定条件を満たすジョブを判定できるよう、たとえば条件が時間ならば<code>execute_at</code> カラムを管理テーブルに用意する。別プロセスで定期的に <code>WHERE execute_at &lt;= NOW()</code> を検索してキューに積む。</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">✅️ 低 (出来合いの設定ウィザードを使える)</td><td style="text-align:left;">✅️ 低 (開始条件次第ではあるが)</td></tr><tr><td style="text-align:left;">柔軟性</td><td style="text-align:left;">❌️ 低 (cron式のような限定された条件のみ)</td><td style="text-align:left;">✅️ 高 (DB/アプリの記述で割と何でもできる)</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（2）を採用する</li><li>条件に合致した後キューまでのタイミングは別プロセスの動作間隔によるので厳密性を要求するとコストが高くなる。一方で（1）の場合でも数分程度のラグが生じうるため、予約機能の実装に際してはある程度の妥協が必要である</li><li>非同期処理の内部で実際の処理を特定の時刻まで待機したり、処理の途中で特定の時間まで sleep loop したりするべきではない。予約を含めたスケジューリングは非同期処理をキックする側の責務として分離すべきである <ul><li>待機中にジョブがクラッシュした場合、リトライ制御が煩雑になるため。また、待機中もスレッドやメモリ、DBコネクションなどのリソースを占有し続けるおそれがある</li></ul></li></ul><div class="mermaid"></div><h2 id="キャンセル" tabindex="-1">キャンセル <a class="header-anchor" href="#キャンセル" aria-label="Permalink to &quot;キャンセル&quot;">​</a></h2><p>キャンセルは保留/中断とは異なり、ステータスの遷移図で終端に位置する想定であるため、再実行は不可となる。</p><p>非同期タスクのキャンセル要件は、以下のようなユースケースで出ることがある。</p><ol><li><strong>ユーザー操作による取り消し</strong>: エンドユーザーが、UI上で実行リクエストした長時間処理（例: レポート生成など）を、完了を待たずに「キャンセル」ボタンを押した場合</li><li><strong>システムメンテナンス</strong>: サービス停止やデプロイに伴い、現在キューに溜まっているジョブの処理を安全に停止させたい場合</li></ol><p>非同期のキャンセル要件は、対応可能なステータスの組み合わせを考えるとシンプルである。通常、以下の2パターンが考えられる。</p><ol><li><code>PENDING</code>（待機中）のみにキャンセル可能とする方針 <ol><li>下表の（1）で対応</li></ol></li><li><code>PENDING</code>（待機中）と<code>RUNNING</code>（実行中）の両方、キャンセル可能とする方針 <ol><li>下表の（1）（2）の両方で対応</li></ol></li></ol><table tabindex="0"><thead><tr><th style="text-align:left;">設計案</th><th style="text-align:left;">（1）実行前ステータスチェック</th><th style="text-align:left;">（2）協調的キャンセル</th></tr></thead><tbody><tr><td style="text-align:left;">対象</td><td style="text-align:left;">PENDING のジョブ</td><td style="text-align:left;">RUNNING 中のジョブ</td></tr><tr><td style="text-align:left;">説明</td><td style="text-align:left;">キャンセルAPIがステータスを CANCELED に変更する。コンシューマーは処理開始直前にステータスを確認し、CANCELED ならば処理をスキップする</td><td style="text-align:left;">RUNNING 中のコンシューマーが、処理の途中で定期的にDBのステータスがCANCELED になってないか確認し、キャンセル済みであれば処理をスキップする</td></tr><tr><td style="text-align:left;">実装難易度</td><td style="text-align:left;">✅️低</td><td style="text-align:left;">❌️高（処理中に定期的なポーリングロジックの実装が必要で、非直感的かつテストもややこしい）</td></tr><tr><td style="text-align:left;">応答性</td><td style="text-align:left;">✅️即時（実行前に停止）</td><td style="text-align:left;">⚠️遅延（ポーリング間隔次第）</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>非同期のキャンセル要件が、本当に必要なのか確認する <ul><li>実行時間が長いタスクをキャンセルすることによるメリットは、多くはシステム稼働費の削減である。具体的にキャンセルされる数の見込みによっては、キャンセルを作り込まない方が良い判断もありえる</li><li>UI/UX上はキャンセルとしての振る舞いができれば、バックエンドの非同期処理自体のキャンセルが不要にできる可能性もある</li></ul></li><li>キャンセルを実現する場合も、できれば（1）のみで済ませられないか検討する <ul><li>（2）の実装は非常にコストが高いため、AIモデルの学習や動画のエンコードで数時間必要といったワークロードでない限り、中断するメリットは低いと考えられる</li></ul></li><li>もし、（2）が必要になったとしても、 <code>RUNNING</code> 中のキャンセル可能な機能対象は絞り込む <ul><li>定期的なポーリングは、共通ライブラリ化（別スレッドやgoroutine）などである程度代替可能だが、テストでの検証などが追加コストが高くなるため、対象は抑えた方が良い</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">強制停止</p><p>非同期タスクが起動済みで、協調的キャンセルではなくインフラ的な停止も考えられる。</p><p>1.ECSジョブ: <code>ecs stop-task</code> 相当の処理で対象のコンテナアプリを停止させる 2.StepFunctionsジョブ: <code>stepfunctions stop-execution</code> 相当の処理で対象のステートマシンを停止させる</p><p>この場合も作り込みは協調的キャンセルと同様に発生するため、できる限り実行前ステータスチェックで済ませるようにすることを推奨する。</p></div><h2 id="通知" tabindex="-1">通知 <a class="header-anchor" href="#通知" aria-label="Permalink to &quot;通知&quot;">​</a></h2><p>非同期処理が終了したかどうかを、エンドユーザーへ通知すべきという要求事項には以下がある。</p><ul><li><strong>即時性</strong>: ユーザーは処理完了をどの程度、リアルタイムで知る必要があるか。別の作業ついでに確認する程度で良いか（≒プッシュ通知は不要）</li><li><strong>ユーザーの状態</strong>: ユーザーは完了を画面上で待機しているか、それとも別の画面で操作しているかなど</li></ul><p>主な実現手段は以下の設計パターンがある。</p><div class="img-bg-transparent"><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）ポーリング方式</th><th style="text-align:left;">（2）プッシュ通知方式</th><th style="text-align:left;">（3）オンデマンド確認方式</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">ブラウザやアプリがポーリングでステータスを確認する方式。ユーザーが画面を開いて待っている前提に近い</td><td style="text-align:left;">処理完了時にサーバー側が、クライアントにWebSocketやモバイルデバイスに通知をプッシュする方式。画面を開いていなくても通知可能</td><td style="text-align:left;">ユーザーが「ジョブ一覧」や「通知一覧」のような専用ページを、自らのタイミングで確認する方式</td></tr><tr><td style="text-align:left;">フロー図</td><td style="text-align:left;"><a href="https://mermaid.live/edit#pako:eNqtVFtrE0EU_ivDPLekRn1ZpNAakeKlxVYKshAmu5N0dbOzzswqJQTcXW0rSWlQm1q11hctisZbi9h6-S9ONzH_wtlubk1SSMCwD5kz53znfN-3e3JQIzqGCmT4toMtDScMlKEoq1pA_mxEuaEZNrI4OG8a2OK98XmcmpiZ6o0nJntjE2zR0uYQu6Va0WUEOjo-HqEoYGZ6dg7EKLYJ5SzGkIlZElnIXGQGi0qiTFnSAlNAfetlUCpWX2wL77fwvgvvowL-7n0LCuvnUnT8z70D4X0Q_mvh_xDeo9pesfbks3A3hVcIXu0GpRXhecL15LGrQ2JSASpEmoZtjnUVHruW99H0CoiPxcFEIytsmFPhTZKakhVh_an46TNnVTgi_zKOuMOicBs231TjKuEYkDuYgoG41cuFYKcxc6tgtDG3YSVtSjIUMzYkeHXTq5cfC7co3EL4SJWW39RKS8KtNDtGiCYhNpghpmlYGZAmFHCJCTSStU3MDdLI6mvzxQsnuhyLRIpFsrUgjpkSjuovHdkZjh2sebUHO-3cxGRHqx4hTvJwDExfGti9TtTQwBAUW_rQTgaV4uH-UreHfVlWn-9Wy5_CCRsSY_3Ez2g4fQfVVura0aNjiv8iaRuv_UUMRawfo2ad8N8Lfytk5a8Ea-Xg10Y4V-3nl6C0enjwVLir169dFu474b6V73nV_xpUng3ESyd3LZMgPelQU_JQYfXhunDvB8v7wt0Q7nZXiyNucARmMc0iQ5eLNxe2USFfwFkcCaHjNHJMHu6bvExFDiez8s2ACqcOHoGUOJkFqKSRyeTJsXXEm1u7FZXb9gYh7TPWDU7olWjVH238_D-jXldr" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/pako:eNqtVFtrE0EU_ivDPLekRn1ZpNAakeKlxVYKshAmu5N0dbOzzswqJQTcXW0rSWlQm1q11hctisZbi9h6-S9ONzH_wtlubk1SSMCwD5kz53znfN-3e3JQIzqGCmT4toMtDScMlKEoq1pA_mxEuaEZNrI4OG8a2OK98XmcmpiZ6o0nJntjE2zR0uYQu6Va0WUEOjo-HqEoYGZ6dg7EKLYJ5SzGkIlZElnIXGQGi0qiTFnSAlNAfetlUCpWX2wL77fwvgvvowL-7n0LCuvnUnT8z70D4X0Q_mvh_xDeo9pesfbks3A3hVcIXu0GpRXhecL15LGrQ2JSASpEmoZtjnUVHruW99H0CoiPxcFEIytsmFPhTZKakhVh_an46TNnVTgi_zKOuMOicBs231TjKuEYkDuYgoG41cuFYKcxc6tgtDG3YSVtSjIUMzYkeHXTq5cfC7co3EL4SJWW39RKS8KtNDtGiCYhNpghpmlYGZAmFHCJCTSStU3MDdLI6mvzxQsnuhyLRIpFsrUgjpkSjuovHdkZjh2sebUHO-3cxGRHqx4hTvJwDExfGti9TtTQwBAUW_rQTgaV4uH-UreHfVlWn-9Wy5_CCRsSY_3Ez2g4fQfVVura0aNjiv8iaRuv_UUMRawfo2ad8N8Lfytk5a8Ea-Xg10Y4V-3nl6C0enjwVLir169dFu474b6V73nV_xpUng3ESyd3LZMgPelQU_JQYfXhunDvB8v7wt0Q7nZXiyNucARmMc0iQ5eLNxe2USFfwFkcCaHjNHJMHu6bvExFDiez8s2ACqcOHoGUOJkFqKSRyeTJsXXEm1u7FZXb9gYh7TPWDU7olWjVH238_D-jXldr?type=png" alt="uml"></a></td><td style="text-align:left;"><a href="https://mermaid.live/edit#pako:eNqVVP1P00AY_lcu9_PIEPWXxpBsDs0iAnEzRtNkOdpjVLpevbtiyLLEdjo0g0hiGIriflKCMWj8iBEV_5ijxf0XXnfbgE0Ma5p-vJ_3PM-btwwNYmKoQYbvedgxcMZCRYpKugPk5SLKLcNykcPBZdvCDh-038KzqZnsoD2THrSl2JJj5BFb0B3lVEVHxsdVFQ3MTOfyIEmxSyhnSYZszArIQfYSs5hKUZEyJZPWADIM7HJsnnBJn6qrgbHRMZDqxFyapeNlHd4ls1lThxrQ4bmx8xcu6jAhPxlH3GPK3CsKK30te-fXQGvrdbi2Er1qiuC3CL6L4IMG_nz9FtbXu9imCMeALGIKzpTWatTD7bpK7SV0YMaR1Zqo_lRZ0csvUeOjBiyn4FJSpJixoZtGL4JW45nwV4Rfj--gHi6_PVyrCX-3e5JTJJLvHDEWME_mMI075aQfTCzKZ0zx1YlTBUwqlpOKd6dftBjpZDaXn5gCUqRCR5I-WN1T_AtT68HmYfNNG1MgAQl_X_jb4f6jaKc5ND_h7srBXm0oOQxScm3cm8ZMeuQYa1PT-eyV2yeAnT60o2D6Wmdcjw_mUYPuZA6I8z_2O7SfmOhunqi-F9WtGFL1cfi0Ee5vxP0Pf30K11YPfjwX_urNG5PCfyf8HTkhUfVzuLt5pvOb5L5jE2QWPGpLFDqMnqwL_2G4vCf8DeE3-1q0kcEELGFaQpYpF1M5bqNDPo9LWNFg4jnk2VyHulORocjjJCcFghqnHk5ASrziPNTmkM3kn-eaiHe3Ws8qt9EdQo7-sWlxQq-rVdjeiJW_KjcQ-g" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/pako:eNqVVP1P00AY_lcu9_PIEPWXxpBsDs0iAnEzRtNkOdpjVLpevbtiyLLEdjo0g0hiGIriflKCMWj8iBEV_5ijxf0XXnfbgE0Ma5p-vJ_3PM-btwwNYmKoQYbvedgxcMZCRYpKugPk5SLKLcNykcPBZdvCDh-038KzqZnsoD2THrSl2JJj5BFb0B3lVEVHxsdVFQ3MTOfyIEmxSyhnSYZszArIQfYSs5hKUZEyJZPWADIM7HJsnnBJn6qrgbHRMZDqxFyapeNlHd4ls1lThxrQ4bmx8xcu6jAhPxlH3GPK3CsKK30te-fXQGvrdbi2Er1qiuC3CL6L4IMG_nz9FtbXu9imCMeALGIKzpTWatTD7bpK7SV0YMaR1Zqo_lRZ0csvUeOjBiyn4FJSpJixoZtGL4JW45nwV4Rfj--gHi6_PVyrCX-3e5JTJJLvHDEWME_mMI075aQfTCzKZ0zx1YlTBUwqlpOKd6dftBjpZDaXn5gCUqRCR5I-WN1T_AtT68HmYfNNG1MgAQl_X_jb4f6jaKc5ND_h7srBXm0oOQxScm3cm8ZMeuQYa1PT-eyV2yeAnT60o2D6Wmdcjw_mUYPuZA6I8z_2O7SfmOhunqi-F9WtGFL1cfi0Ee5vxP0Pf30K11YPfjwX_urNG5PCfyf8HTkhUfVzuLt5pvOb5L5jE2QWPGpLFDqMnqwL_2G4vCf8DeE3-1q0kcEELGFaQpYpF1M5bqNDPo9LWNFg4jnk2VyHulORocjjJCcFghqnHk5ASrziPNTmkM3kn-eaiHe3Ws8qt9EdQo7-sWlxQq-rVdjeiJW_KjcQ-g?type=png" alt="uml"></a></td><td style="text-align:left;">（省略）</td></tr><tr><td style="text-align:left;">即時性</td><td style="text-align:left;">⚠️ポーリング間隔分の遅延が発生</td><td style="text-align:left;">✅リアルタイムに通知できる</td><td style="text-align:left;">❌ (低)ユーザーの操作に依存する</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">⚠️UI側のポーリング・タイムアウト制御ロジックが必要</td><td style="text-align:left;">❌ (高) WebSocket, AWS SNS, FCM/APNsといった通知基盤の設計・運用コストが高い</td><td style="text-align:left;">✅ (低) ステータス一覧APIの実装のみで済む</td></tr><tr><td style="text-align:left;">サーバー費用</td><td style="text-align:left;">✅️ポーリングリクエスト程度</td><td style="text-align:left;">❌ (高) WebSocketコネクションの常時維持や、SNS/FCM連携の費用</td><td style="text-align:left;">✅ (低) ユーザーが必要な時のみに、リクエストが発生</td></tr><tr><td style="text-align:left;">接続性</td><td style="text-align:left;">✅高い</td><td style="text-align:left;">⚠️プロトコルによっては、企業内プロキシ等でブロックされる可能性がある</td><td style="text-align:left;">✅高い</td></tr></tbody></table></div><p>推奨は以下の通り。</p><ul><li><p>（1）または（3）を第一に検討する</p><ul><li>プッシュ通知は構築・運用コストが大きく、ユーザーとしても通知で業務が中断されるため、チャットシステムなど本当に必要な場合のみに適用すべきである（多くの業務システムにおいて（2）はオーバースペックとなる傾向がある）</li></ul></li><li><p>（1）ポーリング方式を選択する場合</p><ul><li>UX向上のため、処理時間が数分程度と短い場合に適している</li><li>ポーリング間隔に指数関数的バックオフを導入するなど、無駄なリクエストを削減する工夫を入れる</li></ul></li><li><p>（2）プッシュ通知方式を選択する場合</p><ul><li>（1）では即時性などの要件を満たせない場合に検討する</li><li>メールやチャットツール（Slack、Teams）など、アプリ通知以外の既存の仕組みを利用できないかも同時に検討する</li><li>アプリ通知を行う場合でも、ポーリングのタイムアウト対策として、（3）との併用が必要になるケースが多い</li></ul></li><li><p>（3）オンデマンド確認方式の実装</p><ul><li>ステータス管理テーブルを参照するだけで実装可能だが、アプリケーション要件の表示項目については、別テーブルでの管理を推奨する（アプリ要件変更時のERD変更影響を局所化するため）</li></ul></li></ul><h3 id="サーバプッシュの方式" tabindex="-1">サーバプッシュの方式 <a class="header-anchor" href="#サーバプッシュの方式" aria-label="Permalink to &quot;サーバプッシュの方式&quot;">​</a></h3><p>サーバプッシュには次の3方式がある。</p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">（2-A）ロングポーリング</th><th style="text-align:left;">（2-B）Server Sent Event</th><th style="text-align:left;">(2-C)WebSocket</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">サーバー側で更新があるまで待機し、更新があったタイミングで応答。再びクライアント側から再接続してもらう</td><td style="text-align:left;">HTTPプロトコルを使用し、クライアントからの一度のリクエストで接続を維持し、サーバから継続的にデータをストリーム送信する</td><td style="text-align:left;">TCP上で双方向通信規格を使用し、サーバ／クライアント間でメッセージを送受信する。バイナリ送信も可能で効率が良い</td></tr><tr><td style="text-align:left;">通信方向</td><td style="text-align:left;">一方向（擬似プッシュ）</td><td style="text-align:left;">一方向（サーバ→クライアント）</td><td style="text-align:left;">双方向</td></tr><tr><td style="text-align:left;">即時性</td><td style="text-align:left;">❌️1度のやり取りでヘッダなどが付与されるためオーバーヘッドあり</td><td style="text-align:left;">⚠️高い</td><td style="text-align:left;">✅️最も低レイテンシ</td></tr><tr><td style="text-align:left;">プロキシ対応</td><td style="text-align:left;">✅️高い</td><td style="text-align:left;">✅️高い</td><td style="text-align:left;">⚠️ブロックされる可能性がほかと比較すると高い</td></tr><tr><td style="text-align:left;">接続維持</td><td style="text-align:left;">❌️自前実装（再接続実装）</td><td style="text-align:left;">✅️自動再接続機能がある</td><td style="text-align:left;">⚠️クライアント側で再接続ロジックを実装</td></tr><tr><td style="text-align:left;">保守運用性</td><td style="text-align:left;">⚠️古い手法である</td><td style="text-align:left;">✅️比較的低い</td><td style="text-align:left;">⚠️ステートフルな通信のため、LBやデプロイ時の切断考慮など運用難易度が高い</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>非同期処理の完了通知という目的（一方向の通知）であれば、（2-B）Server Sent Event (SSE) の採用を推奨する <ul><li>HTTPベースであるため既存のWebインフラ（LB、プロキシ）との親和性が高く、WebSocketほど実装・運用が複雑にならないため</li></ul></li><li>双方向のリアルタイム通信が必要な場合に限り、（2-C）WebSocketを検討する</li></ul><h2 id="同期待ち合わせ" tabindex="-1">同期待ち合わせ <a class="header-anchor" href="#同期待ち合わせ" aria-label="Permalink to &quot;同期待ち合わせ&quot;">​</a></h2><p>非同期処理は元々、呼び出し元と実行側を分離するものである。しかし、処理自体は非同期化しつつも呼び出し元はその処理が完了するまで待機し、結果を同期的に受け取りたい以下のようなユースケースがある。本ガイドラインではこれを「同期待ち合わせ」と呼ぶ。</p><ul><li>平準化目的で非同期化した高負荷な計算処理 <ul><li>例えば、保険料見積もりのような、数万件のシミュレーションや複雑な数理モデルの実行を伴い、CPUとメモリを一時的かつ大量に消費する場合、それ専用のサーバーで実行する</li><li>Web APIの同期呼び出しで行った場合、バーストでシステムが不安定になるため、キューを経由した非同期で処理を行いたい</li><li>保険料見積もり結果は即時、ユーザーに通知させたいため、結果が出てすぐユーザーに通知するため待機する必要がある</li></ul></li></ul><p>本節では、以下のようにエンドユーザー側のポーリングは考慮せず、システム内での待ち合わせのみを範囲とする。</p><div class="mermaid"></div><p>この場合、どのようにプロデューサーが処理完了の応答を受け取るかは、大きく以下の2方式が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）リプライキュー方式</th><th style="text-align:left;">（2）DBポーリング方式</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">Enterprise Integration Patternsにおける<a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html" target="_blank" rel="noreferrer">Request-Replyパターン</a>。Producerが要求メッセージに「応答先キュー名」と「相関ID」を指定し、そのキューを監視して応答を待つ</td><td style="text-align:left;">「ステータス管理テーブル」を利用する。プロデューサーが成功/失敗 ステータスになるまでDBをポーリングする</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">❌️高い。応答用キューの管理、相関IDによる紐付け、タイムアウト処理の配慮が必要</td><td style="text-align:left;">⚠️中。ステータス管理テーブルが前提。プロデューサー側にポーリングとタイムアウトのロジックが必要</td></tr><tr><td style="text-align:left;">即時性</td><td style="text-align:left;">✅️高い。応答メッセージが来たら即座に検知できる</td><td style="text-align:left;">⚠️中。検知までにポーリング間隔分の遅延</td></tr><tr><td style="text-align:left;">インフラ</td><td style="text-align:left;">⚠️応答専用のキューが別途必要</td><td style="text-align:left;">✅️ステータス管理テーブルを再利用できる</td></tr><tr><td style="text-align:left;">耐障害性</td><td style="text-align:left;">✅️プロデューサーが応答待機中に落ちても、キューによるデータ保護が働く</td><td style="text-align:left;">✅️高。ステータスはDBに永続化されるため、プロデューサーが落ちても再ポーリングが可能</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（1）（2）の設計案自体を無くせないかまず検討する。例えば、<a href="#エンドユーザー向け非同期終了の通知">エンドユーザー向け非同期終了の通知</a> 節にあるように、クライアントからのポーリングに書き換えることが最もシンプルである。即時性が犠牲になるが構築難易度が上がるため、よほどの業務効果が無い限りは非推奨である</li><li>即時性などの要件のため同期待ち合わせする必要がある場合は、（1）（2）案から選択する</li><li>前述した「ステータス管理テーブル」を導入する前提であれば、（2）を第一の選択肢とする <ul><li>「ステータス管理テーブル」を再利用でき、DBをそのままポーリングするだけであり設計・運用をシンプルにできるため</li></ul></li><li>どのケースであっても、タイムアウトの設計が必要。例えば方式Bであれば、ポーリングのキャンセルが必要 <ul><li>バックエンド内での待ち合わせをやめ、クライアントに応答を返す設計が必要</li><li>タイムアウト後に、応答が来た場合のハンドリングも検討が必要</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">SQS temporary Queue Client</p><p>応答キューを実装する場合、AWS SQS temporary Queue Clientライブラリを利用すると、 応答用の一時キューの作成・管理・削除を自動化できる。</p><ul><li><a href="https://docs.aws.amazon.com/ja_jp/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-temporary-queues.html" target="_blank" rel="noreferrer">Amazon SQS一時キュー - Amazon Simple Queue Service</a></li></ul></div><h2 id="データ整合性" tabindex="-1">データ整合性 <a class="header-anchor" href="#データ整合性" aria-label="Permalink to &quot;データ整合性&quot;">​</a></h2><p>マイクロサービスアーキテクチャや、SaaS連携と同様に、非同期処理でも「データ整合性」をどのように保つかが問題になりやすい。</p><p>例えば、下図の様なユーザーがサインアップした際、以下のように複数SaaS連携を含む顧客登録フローを想定する。</p><ol><li>自社DBにユーザーを作成</li><li>顧客管理（Salesforceなど）に顧客レコードを作成</li><li>決済基盤SaaS に請求アカウントを作成</li></ol><p>この時、3の非同期部分がエラー発生し、かつ回復不能の場合は、データ不整合が継続してしまう。</p><div class="mermaid"></div><p>上記のような場合で、データ整合性を担保する主な方式は下表の通り。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）Sagaパターン</th><th style="text-align:left;">（2）手動リカバリ</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">失敗したら、取り消す処理（補償トランザクション）を走らせる</td><td style="text-align:left;">失敗したら「人を呼ぶ」</td></tr><tr><td style="text-align:left;">説明</td><td style="text-align:left;">A→B→Cと進み、Cで失敗したら、Bの取消処理→Aの取消処理を実行して元に戻す</td><td style="text-align:left;">エラー時はアラートを上げ、不整合な状態を許容し、運用担当者がデータパッチ等で修正する</td></tr><tr><td style="text-align:left;">データ整合性</td><td style="text-align:left;">✅️高 。APIに取り消し機能が必要。副作用が残る場合あり</td><td style="text-align:left;">✅高。複雑な業務判断が必要な場合に有効</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">❌高。元に戻すロジックが難しい</td><td style="text-align:left;">✅低。検知のみ</td></tr><tr><td style="text-align:left;">運用コスト</td><td style="text-align:left;">✅️低い。自動化できるため</td><td style="text-align:left;">⚠️リカバリ</td></tr></tbody></table><p>Sagaパターンは以下のフローである。補償トンザクションは簡略表示のため決済ワーカーで行っている。本来はキューを経由した処理に切り出すべきである。</p><div class="mermaid"></div><p>推奨は以下の通り。</p><ul><li>Saga以前に設計上の工夫で非同期箇所減らすことができないか検討する <ul><li>例えば、決済基盤への決済アカウント作成までは同期で行い、顧客管理への連携側を非同期化とする。Salesforce連携が万が一遅延しても、売上には影響しないため許容するという判断する。これにより、顧客管理側への登録が失敗しても、補償トランザクションで打ち消すのではなく、その後の運用や救済ジョブで顧客管理側へ後で登録するという一方通行で済ませる</li></ul></li><li>在庫引当のように、失敗したまま放置すると他社の機会損失となり、業務上許容できないようなケースでのみ、（1）を採用する</li><li>Sagaパターンを実現するための取り消しAPIの準備が難しい場合や、発生頻度が低いとされる場合は（2）で様子を見ることも検討する <ul><li>例えば、非同期でのメール送信は取り消すことができない。そのため、別のメールで「取り消しました」と送信するしか無い</li><li>Sagaは複雑な実装のためバグの出る可能性が高い。またレアケースであれば、人間による判断の方がトータルコストは安くなる可能性が高い</li></ul></li><li>（1）（2）のどちらであっても、<a href="#リトライ">リトライ</a> を組み込むことで発生頻度を減らす工夫を必須で行う</li></ul><h2 id="流量制御" tabindex="-1">流量制御 <a class="header-anchor" href="#流量制御" aria-label="Permalink to &quot;流量制御&quot;">​</a></h2><p>現代のクラウドサービスやKafkaなど拡張性が高いプロダクトを利用する前提では、プロデューサー側のメッセージ送信処理にレートリミットのような制限（バックプレッシャー）を設ける必要はなく、またキューが溢れないようにブロッキングされることは無い。</p><p>一方でコンシューマー側については、以下の理由で同時実行数を制限（≒流量調整）する必要がある。</p><ol><li>DBの負荷軽減（スパイクした処理で、DBやシステム全体が不安定になることを防ぎたい）</li><li>ある特定のタスクで、あるリソースが占有されてしまい、他のタスクが起動されないといった占有を防ぐ</li></ol><p>コンシューマーがメッセージを受け取る方式は、大きく常駐型 と イベント駆動型 に分けられ、それぞれ流量制御の方式が異なる。</p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">（1）常駐型（ポーリング型）</th><th style="text-align:left;">（2）イベント駆動型（プッシュ型）</th></tr></thead><tbody><tr><td style="text-align:left;">図</td><td style="text-align:left;"><img src="/arch-guidelines/assets/deamon.drawio.DMmA_WBv.png" alt="SQSをECS常駐サービスで連携"></td><td style="text-align:left;"><img src="/arch-guidelines/assets/event_driven.drawio.XpE4Kwe7.png" alt="SQS Lambdaイベントソースマッピング"></td></tr><tr><td style="text-align:left;">説明</td><td style="text-align:left;">コンシューマーがキューに対し、メッセージを能動的にポーリングし、同期的に処理する構成を指す</td><td style="text-align:left;">（Lambda Event Source Mappingなどのサービス基盤の）ポーリング担当が別のワーカー（実質的にはコンシューマー）にメッセージを割り当てる</td></tr><tr><td style="text-align:left;">構成例</td><td style="text-align:left;">常駐プロセスであるECSタスク、SQLのReceiveMessage APIを呼び出す</td><td style="text-align:left;">SQS + Lambdaや、SQS + Lambda + ECSスタンドアローンタスク（EventBridge Pipesでも同様）</td></tr><tr><td style="text-align:left;">拡張性</td><td style="text-align:left;">常駐プロセス数を増やすことでスケールアウトさせる</td><td style="text-align:left;">事実上プッシュ的に動くため自動でスケールする</td></tr><tr><td style="text-align:left;">縮退性</td><td style="text-align:left;">常駐プロセスをスケールインさせる必要があり大掛かり</td><td style="text-align:left;">タスク処理をLambdaのような基盤で動かせれば柔軟に縮退できる</td></tr><tr><td style="text-align:left;">流量制御</td><td style="text-align:left;">比較的容易</td><td style="text-align:left;">一定の工夫が必要なパターンがある</td></tr></tbody></table><p>（1）の場合は、コンシューマー数:処理スレッド数=1:1 とすることが基本であるため、流量調整はサービス数のスケールイン/アウトで調整できる。</p><p>（2）の場合は実質的にプッシュ型のようにコンシューマーが起動されるため、意図しない並列数の高まりによる過負荷に気をつける必要がある。以下の方式が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（2-1）処理リソース制限</th><th style="text-align:left;">（2-2）実行時に同時実行数を確認</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">コンシューマーを実行する基盤（Lambda, ECSクラスタ）のリソースや同時実行数に上限を設定する方式</td><td style="text-align:left;">起動時に現在の同時実行数を確認して、上限の場合はスリープやリトライさせるか、キューに書き戻す方式</td></tr><tr><td style="text-align:left;">厳密性</td><td style="text-align:left;">⚠️Lambdaの場合は関数単位で「予約済み同時実行数」で並列数を制御できる。ECSクラスタの場合は全体のリソース上限となり厳密な設定は難しい</td><td style="text-align:left;">✅️厳密に行える</td></tr><tr><td style="text-align:left;">設計コスト</td><td style="text-align:left;">✅️低い（インフラ設定）</td><td style="text-align:left;">⚠️制御ロジックがやや複雑</td></tr><tr><td style="text-align:left;">制約</td><td style="text-align:left;">✅️特に無い</td><td style="text-align:left;">❌️ECSの場合、describe APIのレートリミットの懸念</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>実行時間の制約が問題なければ、（2）を第一の選択肢とする <ul><li>Lambdaの場合（2-1）「予約された同時実行」で関数単位に流量調整が可能でありコスト効率も高いため</li><li>Lambdaから <code>ecs run task</code> を呼び出すような構成は、Lambdaの同時実行数を制限しても、最終的にDBなどにアクセスするECSタスクの総数を直接制御できない（クラスタのリソースを絞ることで擬似的に制限は可能だが）できる限り採用しない。ECSを利用する場合は（2-2）ではなく（1）の方式を検討する</li><li>その他の構成においても、（1）や（2-1）が不可な場合に初めて、（2-2）の方式を検討する</li></ul></li><li>Lambdaの実行時間に懸念がある場合、（1）を採用する</li></ul><div class="tip custom-block"><p class="custom-block-title">参考</p><blockquote><p>関連するダウンストリームが高負荷になる可能性を低減するために、Lambda は関数レベルで予約済み同時実行数（Reserved concurrency）、イベントソースレベルで最大同時実行数（Maximum concurrency）を設定</p></blockquote><p><a href="https://aws.amazon.com/jp/blogs/news/introducing-faster-polling-scale-up-for-aws-lambda-functions-configured-with-amazon-sqs/" target="_blank" rel="noreferrer">Amazon SQS をイベントソースとした AWS Lambda 関数のより高速なポーリングスケールアップの紹介</a></p></div><h2 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h2><p>非同期処理における性能は大きく分けて「ロジックの並列化（ファンアウト）」と「コンシューマースケーリング」の2つが存在する。</p><ol><li><strong>ファンイン・ファンアウト</strong>: ある親タスクが、複数の異なるサブタスクに処理を分割・委任するパターン</li><li><strong>コンシューマースケーリング</strong>: キューへ流入するメッセージ量に応じて、同一の処理を行うコンシューマーの計算リソースを増減させるパターン</li></ol><h3 id="ファンイン・ファンアウト" tabindex="-1">ファンイン・ファンアウト <a class="header-anchor" href="#ファンイン・ファンアウト" aria-label="Permalink to &quot;ファンイン・ファンアウト&quot;">​</a></h3><p>1つの重い処理を、複数の独立したサブタスクに分割して並列実行し、必要であれば最後にその結果を合流（ファンイン）することを指す。ファンアウトの実装は比較的容易であるが、ファンインの待ち合わせにはいくつか構成案がある。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">A: DBポーリング</th><th style="text-align:left;">B: オーケストレータ利用</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">親タスクがDBに子タスクを登録。後続処理がDBをポーリングし、全子タスクの完了を待つ</td><td style="text-align:left;">AWS Step Functions の Parallel ステートなどを使い、分岐と合流のロジックを宣言的に定義する</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">⚠️中。ステータス管理テーブルの設計とポーリングロジックが必要</td><td style="text-align:left;">⚠️中。Step Functionsの学習コスト</td></tr><tr><td style="text-align:left;">堅牢性</td><td style="text-align:left;">✅高。DBに状態が永続化される</td><td style="text-align:left;">✅️高。AWSが状態遷移とエラー/リトライを管理するため</td></tr><tr><td style="text-align:left;">可視性</td><td style="text-align:left;">✅️高。SQLで確認可能</td><td style="text-align:left;">✅️実行履歴で視覚的に確認可能</td></tr></tbody></table><p>推奨事項は以下の通り。</p><ol><li>ファンインが不要な場合は、AWSであればSNSを用いたファンアウトを推奨する <ul><li>1つのイベントをSNSトピックに発行し、サブタスクごとに用意したSQSキューで購読する</li></ul></li><li>ファンインが必須な場合、（B）の利用を第一に検討する <ul><li>Parallel ステートは、ファンアウト/ファンインのロジック、リトライ、エラーハンドリング（例: 1つでも失敗したらすべて中止）を宣言的に記述でき実装難易度を下げることができるため</li></ul></li><li>Step Functionsが何かしらの理由で採用できない場合は、Aの方式を検討する</li></ol><h3 id="コンシューマースケーリング" tabindex="-1">コンシューマースケーリング <a class="header-anchor" href="#コンシューマースケーリング" aria-label="Permalink to &quot;コンシューマースケーリング&quot;">​</a></h3><p>キューへのメッセージ流入量の変動に応じて、コンシューマーの計算リソースを動的に増減させることで性能を改善させることができる。逆に流量が減った場合は、コンシューマーの数を減らす（スケールイン）させることで、コスト最適化ができる。スケールアウトしすぎた結果、DBや外部APIなどの依存先に影響を与えることも考慮が必要であるため、<a href="#流量制御">流量調整</a> の章と関連がある。</p><p>スケーリングについては、以下の設計案が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">方式</th><th style="text-align:left;">A: 手動</th><th style="text-align:left;">B: メトリクスベース</th><th style="text-align:left;">C: サーバーレス</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">ECSタスク数などを3など固定で運用する。負荷増減時に運用者が手動で変更する</td><td style="text-align:left;">キューの深さ（ApproximateNumberOfMessagesVisible）や「最も古いメッセージの滞留時間（ApproximateAgeOfOldestMessage）をトリガーに、ECSサービス数を自動で増減させる</td><td style="text-align:left;">SQSイベントソースマッピング + Lambda。メッセージ量に応じてLambdaが自動でスケールする</td></tr><tr><td style="text-align:left;">費用</td><td style="text-align:left;">❌低い。ピーク時に合わせると平常時の無駄が大きい。</td><td style="text-align:left;">✅高い。負荷に追従する。</td><td style="text-align:left;">✅️高い。ゼロスケールも可能</td></tr><tr><td style="text-align:left;">応答性</td><td style="text-align:left;">⚠️低い。スパイク負荷時にキューが滞留する。</td><td style="text-align:left;">⚠️中。スケールアウト（タスク起動）までに数分かかる</td><td style="text-align:left;">✅高い。Lambdaのスケールアウトは非常に数秒レベル</td></tr><tr><td style="text-align:left;">流量制御</td><td style="text-align:left;">✅容易。タスク数が物理的な上限となる</td><td style="text-align:left;">✅容易。最大タスク数を設定可能</td><td style="text-align:left;">✅️Lambdaの「予約された同時実行数」で制御できる</td></tr></tbody></table><p>推奨は以下の通り。</p><ol><li>Cを第一に選択する <ul><li>SQS + Lambda のイベントソースマッピングは、容易さ・ゼロスケール・費用効率が良いため</li><li>Lambdaの実行時間制限（最大15分）やリソース制限に収まる処理であれば、積極的に採用すべきである。</li><li>Lambdaの場合、コールドスタートがレイテンシの影響が無視できない場合は、「Provisioned Concurrency（プロビジョニングされた同時実行数）」の設定を検討する</li></ul></li><li>Lambdaの実行時間制限に許容できない場合、Bを検討する <ul><li>Aは実現が容易であるが、クラウドの弾力性を活かしているとは言い切れないため、できる限りBを目指しコスト最適化を目指す</li></ul></li><li>どの方式であれ、最大同時実行数を設定する。<a href="#流量制御">流量調整</a>で述べた通り、依存先を保護することがスケーリングより優先すべきである</li></ol><h2 id="セキュリティ" tabindex="-1">セキュリティ <a class="header-anchor" href="#セキュリティ" aria-label="Permalink to &quot;セキュリティ&quot;">​</a></h2><p>非同期処理におけるセキュリティは、インフラ全般のセキュリティ事項と強く重複する。<a href="https://future-architect.github.io/arch-guidelines/documents/forAWS/" target="_blank" rel="noreferrer">AWS設計ガイドライン</a> における基本的な対策は実施することを前提とする。また、利用するキューは <a href="#キュー環境">キュー環境</a> の推奨にある通り、マネージドサービスを前提とする。もし、その他のミドルウェアを利用する場合は、ユーザー名・パスワードの管理を、AWSであればSystem Manager やKMSなどで機密情報管理をする必要がある。</p><p>推奨は以下の通り。</p><ul><li>SQSへのメッセージ登録は、必ずWeb APIサーバーを経由させるなどの構成を取り、直接メッセージングサービスを外部に露出させない</li><li>インフラレベルの基本的なアクセス制御を実施する <ul><li>最小権限の原則に従い、必要なサービスのみがキューへの登録/参照の権限を付与する</li><li>VPCエンドポイントを利用し、インターネットに露出させない</li><li>サーバーサイド暗号化を有効にする（SQSであればSSE-SQSなど。コンプライアンス要件次第でSSE-KMSにする）</li></ul></li><li>ペイロードには、機密情報を入れない <ul><li>例えば、個人情報（PII）などをそのまま含めない</li><li>暗号化したDBなどに格納し、コンシューマーからはペイロードに含めたキー経由で参照渡し的に取得してもらう</li></ul></li><li>クライアントサイドの暗号化 <ul><li>ペイロードに直接、機密情報が含まれておらず、IDやキーだけであったとしても、PCI-DSSの場合は暗号化を求められる可能性があるため、個別に対応を検討する</li><li>特に設定されたコンプライアンス要件がない場合は対応不要とする</li></ul></li><li>コンシューマーは、不正なメッセージを処理してしまわないようにバリデーションを実施する <ul><li>AsyncAPIやJSON Schemaレベルのチェックや、ビジネス上の意味論的に問題ないデータのみを処理する</li></ul></li></ul><h2 id="トレーシング" tabindex="-1">トレーシング <a class="header-anchor" href="#トレーシング" aria-label="Permalink to &quot;トレーシング&quot;">​</a></h2><p>非同期処理が複数のサービスやキューをまたいで連鎖すると、障害調査や性能ボトルネックの調査などの難易度が高まる。そのため、トレースID（トランザクションID）を非同期処理の呼び出し時に設定し、それらを引き回すことで紐づけを容易にするという、分散トレーシングは必須であるとされる。</p><p>推奨は以下の通り。</p><ul><li>非同期処理の呼び出し時に、トレースIDの設定は必須とする</li><li>トレースIDは、呼び出し元のシステムなど、なるべくシステムの上流で採番する（Web APIであれば、API Gatewayなどの層。バッチであればバッチ実行時に採番する） <ul><li>Web API設計ガイドライン &gt; <a href="/arch-guidelines/documents/forWebAPI/web_api_guidelines.html#トレースidをどこで払い出すべきか">トレースIDをどこで払い出すべきか</a> を参考にする</li></ul></li><li>トレースIDは、UUID v4かv7を用いる <ul><li>基本的には推測困難性は不要だと考えられるため、v7で良いと考えられる</li></ul></li><li>トレースIDは、非同期処理・それらから呼び出される別の非同期処理などの全てのログ項目や、DBのシステム共通項目で必須とする</li><li>トレースIDは、ペイロードの本文に含めず、できる限りメッセージのメタデータとして付与させる（例えば、HTTPヘッダーやSQSのメッセージ属性） <ul><li>リラン、リカバリ時に切り替えさせることができるようにしたいため</li></ul></li><li>各プログラムから、トレースIDの引き回しは、JavaであればMDC (Mapped Diagnostic Context)や、Goであればcontext などの機能を利用する（<a href="https://future-architect.github.io/arch-guidelines/documents/forLog/log_guidelines.html#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B7%E3%82%99%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9" target="_blank" rel="noreferrer">ログ設計ガイドライン</a>を参照する）</li></ul><div class="tip custom-block"><p class="custom-block-title">AWS X-Rayを利用する</p><p>AWS環境で非同期処理のトレーシングを行う場合、<a href="https://aws.amazon.com/jp/xray/" target="_blank" rel="noreferrer">AWS X-Ray</a>の利用を推奨する。</p><p>この場合アプリケーションのSDK（例: AWS X-Ray SDK for Java）を導入し、設定を有効化するだけで、SDKが自動的にトレースID（X-Rayでは <code>Trace ID</code>、 <code>Segment ID</code> と呼ばれる）の採番と引き回しを行う。特にSQSとの連携では、プロデューサーの <code>SendMessage</code> 側で自動的に <code>Trace ID</code> がメッセージ属性に追加され、コンシューマーの <code>ReceiveMessage</code> 側でSDKがそれを自動的に読み取り、トレースの親子関係を連結してくれる。これにより、開発者が手動でIDを引き回す実装（MDCへの設定など）の多くを省略でき、X-Rayのコンソール上でサービスマップや処理のボトルネックを可視化できるようになる。この場合は、スクラッチで採番したトレースIDは、以下のように別名で追加して紐づける。ALBの場合は自動で<code>X-Amzn-Trace-Id</code> が付与され、API Gatewayの「X-Ray トレースを有効にする」ことで有効になる。X-Rayを利用する場合は、自前でのトレースID採番を止め、AWS側の自動採番を用いることを推奨する。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">XRay.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">putAnnotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CorrelationID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">紐づけ用のキー</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></div><h3 id="トレーシングの親子関係" tabindex="-1">トレーシングの親子関係 <a class="header-anchor" href="#トレーシングの親子関係" aria-label="Permalink to &quot;トレーシングの親子関係&quot;">​</a></h3><p>トレースIDは、ユーザーのリクエストから始まる一連の処理全体を紐づけるIDである。OpenTelemetryなどの分散トレーシングシステムの文脈では、トレースを構成する個々の作業単位をスパンと呼ぶ。ある親スパンが子スパンを呼び出すという親子関係も定義されている。親子関係が存在することで、例えばファンアウトのような分岐構造を把握できる。</p><p><img src="/arch-guidelines/assets/tracing.drawio.CKAaORze.png" alt="トレーシングの親子関係でファンアウトさせた例"></p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Trace: T1</span></span>
<span class="line"><span>[Span A: Order API (Root)] ---------------------------------</span></span>
<span class="line"><span>     [Span B: Shipping Consumer] -----------------------</span></span>
<span class="line"><span>     [Span C: Email Consumer] ---------------------------</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>親子関係を記録することで、トレースID(T1)だけでは分からなかった「API(A)が2つのConsumer(B, C)を並列で呼び出した」という分岐構造（ファンアウト）が可視化される。</p><p>このような管理手法以外に、トレースIDを「親ID_子供ID_孫ID_…」のように区切り文字で結合して保持するという直感的だが少し原始的な設計案も考えられる。これはキーが長大になりすぎることのデメリットもよく伺う。</p><p>推奨は以下の通り。</p><ul><li>原則、分散トレーシングの考えに乗っ取り、親子関係を管理したい場合は、SpanID, ParentSpanIDを導入する</li><li>非同期の実行管理テーブルに、trace_id, span_id, parent_span_id を列として持たせる。起動順序を特定したい場合、これらの情報を元にSQLで再帰CTEなどのクエリを利用してトレースする</li><li>トレーシング基盤が存在する場合は、 W3C Trace Contextなどが定める標準（`traceparent`ヘッダなど）に従い紐づけ情報を連携する</li></ul><h2 id="監視" tabindex="-1">監視 <a class="header-anchor" href="#監視" aria-label="Permalink to &quot;監視&quot;">​</a></h2><p>非同期システムは、処理がバックグラウンドで行われるため、稼働状況の把握が難しい。そのため、処理の遅延・停止・失敗などの問題発生の検知と、原因を特定するため監視設計は、同期システム以上に重要である。</p><h3 id="監視種別" tabindex="-1">監視種別 <a class="header-anchor" href="#監視種別" aria-label="Permalink to &quot;監視種別&quot;">​</a></h3><p>監視対象のメトリクスは、大きく分けて「（1） インフラメトリクス」と「（2） アプリケーションメトリクス」の2つに大別できる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">設計案</th><th style="text-align:left;">（1）インフラメトリクス監視</th><th style="text-align:left;">（2）アプリケーションメトリクス監視</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">クラウドサービスが提供するキューやコンシューマーの基本的なメトリクス（メッセージ数、最古メッセージの経過時間など）を監視する方式</td><td style="text-align:left;">プロデューサー/コンシューマーのアプリケーションコード内に、処理時間や成功/失敗率といったカスタムメトリクスやログを埋め込む方式</td></tr><tr><td style="text-align:left;">目的</td><td style="text-align:left;">インフラの健全性</td><td style="text-align:left;">ビジネスロジックの健全性</td></tr><tr><td style="text-align:left;">検知対象</td><td style="text-align:left;">キューの滞留、コンシューマーの停止</td><td style="text-align:left;">処理レイテンシ、エラー率、スループット</td></tr><tr><td style="text-align:left;">実装コスト</td><td style="text-align:left;">✅ 低い （インフラ設定のみ）</td><td style="text-align:left;">⚠️ 中 （コードへの計装が必要）</td></tr></tbody></table><p>通常、（2）が必要になることは少ないと考えられる。なぜなら、非同期タスクの実行失敗は、（1）や適切なログ出力で検知可能であるためである。検知対象行のように、処理レイテンシやスループットなどの計測が必要な特殊なケースでのみ、（2）が必要となる。</p><p>推奨は以下の通り。</p><ul><li>（1）を必須とする</li><li>処理レイテンシやエラー率などのSLO/SLAが定義されている場合は、（2）の導入を “検討” する <ul><li>SLO/SLAが定義されていても、基盤メトリクスのみでできる限り対応できないか検討する</li><li>もし、SLO/SLAを設定するような領域でない場合（例えば、業務システムで基本的には全てのエラーメッセージを処理する必要があるなど）であれば、（2）を導入せず（1）でカバーさせる</li></ul></li></ul><h3 id="dlq監視" tabindex="-1">DLQ監視 <a class="header-anchor" href="#dlq監視" aria-label="Permalink to &quot;DLQ監視&quot;">​</a></h3><p>DLQに入るということはエラーが発生したことである。エラーの検知は、アプリ側でDLQに入れるタイミングでエラーログ出力させるか、インフラ側でキュー数を監視させるかの2方式が存在する。</p><table tabindex="0"><thead><tr><th style="text-align:left;">観点</th><th style="text-align:left;">（1） アプリケーションログによる検知</th><th style="text-align:left;">（2） DLQのメトリクス監視</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">コンシューマーが処理失敗を検知した際、アプリケーション側が詳細なエラーログを出力する。ログ監視がエラーレベルから検知&amp;通知させる</td><td style="text-align:left;">クラウドサービスが提供するDLQのメトリクス（例: ApproximateNumberOfMessagesVisible）を監視し、&gt; 0になったらアラート</td></tr><tr><td style="text-align:left;">検知タイミング</td><td style="text-align:left;">処理失敗の即時 (リトライの最後だけログ出力と行った制御が行いにくい)</td><td style="text-align:left;">メッセージがDLQに格納された時点</td></tr><tr><td style="text-align:left;">得られる情報</td><td style="text-align:left;">✅詳細を自由に出力可能</td><td style="text-align:left;">⚠️限定的。原因分析に追加調査が必要</td></tr><tr><td style="text-align:left;">耐障害性</td><td style="text-align:left;">⚠️アプリのバグ（ログ出力前にクラッシュ等）で、障害を取りこぼすリスク</td><td style="text-align:left;">✅高い</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>どちらの手法であっても、DLQの滞留時間（例えば、1日以上放置されているなど）のメトリクス監視は行う</li><li>Lambdaなど処理自体のリトライで救済される可能性がある場合、（1）ではなく（2）で監視する <ul><li>エラーが出たがリトライにより救済された場合、監視通知の偽陽であり、運用者として信頼しなくなる（無視する）ことで、他の障害検知フローが形骸化する懸念の方が深刻であるため</li><li>アプリ側のログはあくまで、INFOなどレベルを落として出力し、トレースID（トランザクションID）で紐づけて取得可能にしておく</li></ul></li><li>アプリ側で厳格に、リトライ回数を把握でき、リトライしても処理が失敗したと分かるようであれば（1）で監視し、（2）は行わない <ul><li>アプリケーションログ経由のほうが、障害調査の効率を上げることができ、メッセージコードに紐づく運用などの高度化を目指すことができるため</li><li>アプリのクラッシュは、非同期タスク自体が未完了であるのでキューのデータ欠損はしないと考えられる。最悪、DLQの滞留チェックで検知可能</li></ul></li></ul><h3 id="遅延監視" tabindex="-1">遅延監視 <a class="header-anchor" href="#遅延監視" aria-label="Permalink to &quot;遅延監視&quot;">​</a></h3><p>非同期処理が円滑に行われていることを保証するために、以下の観点で状況を把握できる必要がある。</p><ul><li><strong>レイテンシ</strong>: メッセージがキューに滞留し、処理が遅延していないか。コンシューマー側の処理能力不足を検知</li><li><strong>スループット</strong>: システムは単位時間あたりにどのくらいのメッセージを詰まらずに流せているか。レイテンシは低いがプロデューサー側がメッセージを上手く送信できていない状態を検知</li></ul><p>推奨は以下の通り。</p><ul><li>AWS設計ガイドラインの<a href="https://future-architect.github.io/arch-guidelines/documents/forAWS/aws_guidelines.html#sqs" target="_blank" rel="noreferrer">SQS</a>や<a href="https://future-architect.github.io/arch-guidelines/documents/forAWS/aws_guidelines.html#kinesis-data-streams" target="_blank" rel="noreferrer">Kinesis Data Streams</a>の監視項目を参考にする</li><li>処理遅延が許されない場合は、以下の考え方で監視する</li></ul><p>SQSの場合、具体的な監視項目は以下を参考にする。</p><table tabindex="0"><thead><tr><th style="text-align:left;">観点</th><th style="text-align:left;">SQS/Lambdaの場合のメトリクス例</th></tr></thead><tbody><tr><td style="text-align:left;">レイテンシ</td><td style="text-align:left;">AgeOfOldestMessage<br>最も古いメッセージがキューに投入されてからの経過時間</td></tr><tr><td style="text-align:left;">スループット</td><td style="text-align:left;">NumberOfMessagesDeleted/NumberOfMessagesSent<br>キューから削除されたメッセージ数/キューに正常に追加されたメッセージ数</td></tr></tbody></table><h2 id="dlq" tabindex="-1">DLQ <a class="header-anchor" href="#dlq" aria-label="Permalink to &quot;DLQ&quot;">​</a></h2><p>DLQ（Dead Letter Queue: デッドレターキュー）とは、処理に失敗したメッセージを退避させるための特別なキューである。主に以下の目的がある。</p><ol><li><strong>無限ループの防止:</strong> 処理に失敗したメッセージが何度も再試行され、リソースを無限に浪費し続ける事態を防ぐ</li><li><strong>障害調査:</strong> 処理に失敗したメッセージを隔離・保持することで、エラーの原因分析を容易にする</li><li><strong>手動リカバリ:</strong> 根本原因（例: バグ修正、連携先障害の復旧）を解決した後、DLQに退避したメッセージをリランさせるための手段となる。どこかに永続化させておかないとリランに困るが、元のキューへは送信不可であるためDQLが必要となる</li></ol><h3 id="dlq構成" tabindex="-1">DLQ構成 <a class="header-anchor" href="#dlq構成" aria-label="Permalink to &quot;DLQ構成&quot;">​</a></h3><p>DLQには主に以下の2パターンの設計が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）単一のDLQ</th><th style="text-align:left;">（2）キューごとのDLQ</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">全キューからの失敗メッセージを単一のDLQに集約する方式</td><td style="text-align:left;">キューごとにDLQを構築する方式</td></tr><tr><td style="text-align:left;">構築コスト</td><td style="text-align:left;">✅️DLQのインフラ数を抑えることができる</td><td style="text-align:left;">⚠️メインのキュー:DLQ=1:1</td></tr><tr><td style="text-align:left;">設計コスト</td><td style="text-align:left;">✅️単一であるためシンプル</td><td style="text-align:left;">✅️1:1であるためシンプル</td></tr><tr><td style="text-align:left;">リラン</td><td style="text-align:left;">❌️エラーがどのキューから発生したか特定する処理が必要</td><td style="text-align:left;">✅️1:1であるためシンプル</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（2）を採用する <ul><li>ソースキューごとにDLQを設定することがクラウド構築のベストプラクティスである（障害発生時の影響範囲の特定、リカバリ運用がシンプル）</li><li>多くのマネージドサービスのキューが、データ量（メッセージ数）による従量課金がコストドライバーであるため（Amazon Kinesis Data Streamsはシャードでの課金もあるため、利用サービスごとに確認すること）</li></ul></li></ul><h3 id="dlqへの退避方針" tabindex="-1">DLQへの退避方針 <a class="header-anchor" href="#dlqへの退避方針" aria-label="Permalink to &quot;DLQへの退避方針&quot;">​</a></h3><p>本ガイドラインではデフォルトFIFOキューを利用することを推奨している。この場合、ポイズンピルと呼ばれる処理不能なメッセージが1件でも存在すると、同一メッセージグループの後続処理が詰まるというヘッドオブラインブロッキングが発生する。<a href="#順序保障">順序保障</a> 章にあるように、厳格な順序保障が求められる場合はブロッキングされることが正しい。しかし、ここではシステム全体の可用性を維持することを優先し、ポイズンピルメッセージはDLQに転送する前提とする。この場合、次の3方式が考えられる。</p><p>この退避を実現するためには、以下の3つの方式が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">項目</th><th style="text-align:left;">（1）アプリケーション制御</th><th style="text-align:left;">（2）インフラ制御</th><th style="text-align:left;">（3）二段構え</th></tr></thead><tbody><tr><td style="text-align:left;">概要</td><td style="text-align:left;">アプリケーションが明示的にDLQへメッセージを送信する</td><td style="text-align:left;">アプリは例外をスローし、SQSの <code>maxReceiveCount</code> 超過による自動転送機能に任せる</td><td style="text-align:left;">明確なエラーはアプリで即時退避し、予期せぬエラーはインフラ機能で救済するハイブリッド方式</td></tr><tr><td style="text-align:left;">ブロッキング解消</td><td style="text-align:left;">✅ 即座に解消される</td><td style="text-align:left;">⚠️ 規定回数のリトライを待つため、DLQ移動までのタイムラグが発生する</td><td style="text-align:left;">✅ 既知のエラーであれば即座に解消される</td></tr><tr><td style="text-align:left;">クラッシュ耐性</td><td style="text-align:left;">⚠️ OOMなどクラッシュを検知できず、無限に詰まるリスク</td><td style="text-align:left;">✅ アプリがクラッシュしても、インフラ側で検知して確実に退避される</td><td style="text-align:left;">✅ 予期せぬエラーはインフラ機能がカバーする</td></tr><tr><td style="text-align:left;">実装難易度</td><td style="text-align:left;">⚠️ DLQへの送信・削除ロジックの実装が必要</td><td style="text-align:left;">✅ コード修正は不要（例外スローのみ）、インフラ設定のみ</td><td style="text-align:left;">⚠️ アプリケーション実装とインフラ設定の両方が必要となる</td></tr><tr><td style="text-align:left;">データ整合性</td><td style="text-align:left;">⚠️ 送信成功・削除失敗時の重複リスクあり</td><td style="text-align:left;">✅ SQSの機能内でアトミックに移動が行われる</td><td style="text-align:left;">⚠️ アプリ制御側において、重複排除やメタデータ継承の工夫が必要</td></tr><tr><td style="text-align:left;">エラー情報の詳細</td><td style="text-align:left;">✅ DLQ送信時に、エラー理由やコンテキストを属性として付与可能</td><td style="text-align:left;">⚠️ 元のメッセージがそのまま移動するため、失敗理由はログ確認が必要</td><td style="text-align:left;">✅ （アプリ制御側で対応可能）</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（3）二段構え を採用する <ul><li>アプリケーションロジックで判断可能なエラーは即座に排除し、予期せぬクラッシュはインフラで拾うことで、FIFOキューの弱点であるブロッキング時間を最小化しつつ、堅牢性を最大化する</li><li><code>maxReceiveCount</code> はあくまで無言実行を防ぐためのセーフティーネットであり、アプリケーションで行いたい最大リトライ数を上回る数値を設定する。大き過ぎる値を設定すると、可視性タイムアウトの値とかけ合わせた時間がブロッキングされる。例えば、<code>maxReceiveCount</code> を10、可視性タイムアウトが30秒の場合、コンシューマーの実行時間分＋5分ブロックされることになる</li><li>前提条件 <ol><li>ステータス管理テーブルによる冪等性（アプリケーションによる手動DLQ転送とメインキューからの削除はアトミックな操作ではないことから重複実行への対策が必要であるため）</li><li>メタデータの完全な継承（アプリケーションで転送する際、<code>MessageGroupId</code>や、トレースIDなどのメタデータをプログラム内で明示的にコピーしてDLQへ送信すること。これが行われない場合、リカバリ時に順序が崩れる原因となる。）</li></ol></li></ul></li></ul><p>二段構えの防御における、メッセージ処理と分岐のフローを次に示す。</p><div class="mermaid"></div><h3 id="dlqリカバリ" tabindex="-1">DLQリカバリ <a class="header-anchor" href="#dlqリカバリ" aria-label="Permalink to &quot;DLQリカバリ&quot;">​</a></h3><p>デッドレターキューから再実行するためには、以下の方式が考えられる。</p><table tabindex="0"><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">（1）ソースキューに書き戻す</th><th style="text-align:left;">（2）DLQからタスクを実行</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">DLQから元のソースキューにメッセージを書き戻すことで、元のキューから非同期タスクを実行する方式</td><td style="text-align:left;">一時的に、ジョブ実行基盤からDLQを読み込ませる方式</td></tr><tr><td style="text-align:left;">設計コスト</td><td style="text-align:left;">✅️非同期ジョブの設計はDLQなどの意識が不要</td><td style="text-align:left;">❌️ソースキューとDLQの2つの読み込みの考慮が必要</td></tr><tr><td style="text-align:left;">運用コスト</td><td style="text-align:left;">✅️メッセージだけ移し替えるだけであるため、インフラレベルの変更をせずリラン可能</td><td style="text-align:left;">❌️一時的にDLQ読み込みをさせる構成変更が必要で、リラン運用の手順が複雑である</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>（1）を採用する <ul><li>コンシューマーの実装をシンプルに保つことができる</li></ul></li><li>DLQからソースキューに転送する、リラン専用のジョブを作成しておく <ul><li>リランのオペレーションを統一することで、運用性を向上させるため</li></ul></li></ul><h3 id="dlqのメッセージ保持方針" tabindex="-1">DLQのメッセージ保持方針 <a class="header-anchor" href="#dlqのメッセージ保持方針" aria-label="Permalink to &quot;DLQのメッセージ保持方針&quot;">​</a></h3><p>メッセージには通常、最大保持期間（例: AWS SQSでは最大14日間）が存在する。即時リカバリするような領域であれば問題ないが、解決までビジネス的な判断が必要であったり、監査要件で失敗したデータを長期間保持する必要がある場合は、DBやオブジェクトストレージにメッセージを保持しておく必要が出てくる。</p><p>DLQのメッセージ永続化について、主に以下の設計案がある。</p><table tabindex="0"><thead><tr><th style="text-align:left;">設計案</th><th style="text-align:left;">（1）DLQの保持期間に依存</th><th style="text-align:left;">（2）失敗時にDB/ストレージへ永続化</th><th style="text-align:left;">（3）DLQから定期的にアーカイブ</th></tr></thead><tbody><tr><td style="text-align:left;">説明</td><td style="text-align:left;">クラウドサービスのDLQ機能のみを利用し、その保持期間（例: 14日間）を上限とする方式</td><td style="text-align:left;">コンシューマーでの処理失敗を検知した時点で、メッセージ内容をDBやオブジェクトストレージ（S3など）に書き出す方式</td><td style="text-align:left;">DLQを定期的にポーリングするバッチを用意し、メッセージが失効する前にDB/ストレージに退避させる方式</td></tr><tr><td style="text-align:left;">構築コスト</td><td style="text-align:left;">✅ 低い (インフラ設定のみ)</td><td style="text-align:left;">⚠️ 中 (アプリで実装が面倒)</td><td style="text-align:left;">⚠️ 中 (アプリはシンプルになるが、アーカイブのバッチ処理が別途必要)</td></tr><tr><td style="text-align:left;">調査コスト</td><td style="text-align:left;">⚠️メッセージ本文の確認は手間が大きい</td><td style="text-align:left;">✅️DBでペイロードの確認が可能</td><td style="text-align:left;">⚠️メッセージ本文の確認は手間が大きい</td></tr><tr><td style="text-align:left;">リラン性</td><td style="text-align:left;">✅ 低い</td><td style="text-align:left;">⚠️ 中 (データパッチ的なリカバリ運用が必要)</td><td style="text-align:left;">⚠️ 中 (データパッチ的なリカバリ運用が必要)</td></tr><tr><td style="text-align:left;">保持期間</td><td style="text-align:left;">❌ 短い (サービスの制約に依存)</td><td style="text-align:left;">✅ 無期限</td><td style="text-align:left;">✅ 無期限</td></tr></tbody></table><p>推奨は以下の通り。</p><ul><li>原則、（1）を採用する。保持期間は最大（SQSであれば14日）を選択する <ul><li>基本的に業務判断が求められるようなリラン要件は存在しないと考えられるため</li></ul></li><li>失敗データの解決に数週間以上かかる可能性がある場合は、（2）を選択する <ul><li>ただし、非同期処理の全てではなく、解決に時間がかかる該当の機能のみの特殊対応とする</li></ul></li></ul><h2 id="テスト" tabindex="-1">テスト <a class="header-anchor" href="#テスト" aria-label="Permalink to &quot;テスト&quot;">​</a></h2><p>※テスト全体計画に従って実施する。</p><p>非同期処理と言っても、ユニットテスト・結合テストなどは通常の機能開発と変わらない観点で行うべきである。</p><p>共通する主なテスト実行観点。</p><ul><li>静的解析などでリンターの利用</li><li>テスト自動化（xUnit）の利用</li><li>CIでのリンター実行、回帰テスト</li></ul><p>バッチにも共通するため、非同期に限った話ではないが、以下の観点はユニットテストでも確認する。</p><ul><li>冪等性のテスト</li></ul><p>非同期特有の事情として、キューを挟むため、プロデューサー・コンシューマー間の認識ミスで不具合が生じやすい。そのため、結合テストも自動化することが望ましい。例えば、Web API（プロデューサー） -&gt; キュー -&gt; コンシューマー の部分である。</p><ul><li>Testcontainerなどの利用しモックではなく本物のキューを用いて、結合テスト（E2Eテスト）を自動化する</li><li>結合テストは実行時間が長い（コストが大きい）ため、正常系だけに絞って実施する</li><li>ただし、代表的な1機能に限り、DLQへの転送もテスト化（処理失敗でN回のリトライ後、DLQに正しく転送されているか）することが望ましい</li></ul><h3 id="負荷テスト" tabindex="-1">負荷テスト <a class="header-anchor" href="#負荷テスト" aria-label="Permalink to &quot;負荷テスト&quot;">​</a></h3><p>※テスト全体計画に従って実施する。</p><p>非同期特有の事情として、キューへの投入後、コンシューマー処理が非機能要件定義で定めた性能が出ているかを確かめる必要がある。この際、Web API側からラッシュテストを行うことで、Web APIの性能テストも一緒に実行できるため楽である。一方で、単体素性能を確認したい場合は、キューにメッセージを直接投入することで、余計なノイズを無くして性能を測ることができる。</p><p>推奨は以下の通り。</p><ul><li>本番想定の負荷を一定期間（例: 15分など）かけて以下を検証する <ul><li>コンシューマーアプリが、非機能要件を満たす想定した処理量をさばけているか</li><li>利用するDBなどのミドルウェアのCPU、I/O、メモリなどのリソースが想定を下回っているか</li></ul></li><li>オートスケールアウト、オートスケールインも設計上含まれているのであれば、このタイミングで検証する</li><li>まず、直接キューにメッセージを送信してコンシューマーの性能を確認する、単体素性能のテストを実施してから、Web APIを経由した通しのテストを最後に実施する <ul><li>負荷試験環境のセットアップミスやアプリの設定ミスで、うまくキューからコンシューマーにメッセージが連携されないことも多々あり、最初から通しでテストすると負荷テストの着手が遅れがちのため</li><li>Web APIを経由することで、Web API側が思ったより性能が出ず、結果的にWeb APIで流量調整がなされてしまいコンシューマー側のテストにならず、不具合の検知が遅れるというリスク回避のため</li></ul></li><li>単体素性能をシンプルに計測した後に、Web APIを通したテストも実施することで、非同期に切った意味があるか（Web APIの同期部分のレイテンシが小さく保てているか）を確認する</li></ul><h3 id="障害・運用テスト" tabindex="-1">障害・運用テスト <a class="header-anchor" href="#障害・運用テスト" aria-label="Permalink to &quot;障害・運用テスト&quot;">​</a></h3><p>※テスト全体計画に従って実施する。</p><p>監視で設定した内容が機能するか、障害テストで確認する必要がある。</p><p>推奨は以下の通り。</p><ul><li>メインキューからDLQに転送された場合、適切に検知・通知されるか確認する</li><li>DLQからメインキューに書き戻すといった、運用手順が想定通りに行えるか検証する</li></ul><h2 id="ドキュメント" tabindex="-1">ドキュメント <a class="header-anchor" href="#ドキュメント" aria-label="Permalink to &quot;ドキュメント&quot;">​</a></h2><p>非同期処理は、キューへのメッセージ登録が、事実上API呼び出しとして考えることができる。そのため、キューにどのようなペイロードを送信すべきか、インタフェース定義を記載することが望ましい。また、処理が非同期でぶつ切れになるため、機能単位の設計書レベルから全体像を掴むことが難しくなるため、どのようにイベントが伝播するか構成図で捉えられるようにすることが求められる。</p><p>推奨は以下の通り。</p><ul><li>（非同期に限った話ではないが）フロー図・インタフェース定義・機能定義書それぞれの紐づけは、機能IDで可能とする</li></ul><h3 id="イベントフロー図" tabindex="-1">イベントフロー図 <a class="header-anchor" href="#イベントフロー図" aria-label="Permalink to &quot;イベントフロー図&quot;">​</a></h3><p>非同期処理を導入する場合、なぜ非同期なのかという設計意図は重要である。これが無いと、後々の運用メンバーが「同期」に戻すべきではないかと悩みが発生する。また、どのコンポーネントがどのキューに依存するかが分からないと、影響度調査などで大きな苦労を伴う（依存関係を調査する必要があり、時間がかかってしまう）。特にコンシューマーが別のキューにメッセージを送信するという、別の非同期が連鎖的に呼ばれる場合は複雑度が増すため、構成図を作成し全体像が分かるようにする必然性が増す。</p><p>推奨は以下の通り。</p><ul><li>各イベントの連鎖が分かるようなイベントフロー図を構築するか、Web API機能設計書にPlantUMLや<a href="http://mermaid.js" target="_blank" rel="noreferrer">mermaid.js</a> でシーケンス図を書く <ul><li>メッセージ種別が少なければシステム構成図でまとめても良い</li><li>非同期が連鎖する場合は、イベントフロー図や上流のWeb API設計書のシーケン図を参照するようリンクを付ける</li></ul></li><li>まず「なぜ非同期なのか」という設計意図を記載する <ul><li>例: 「外部APIの遅延からUIを解放するため」「負荷平準化のため」</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">イベントフロー図とシーケンス図のサンプル</p><p><img src="/arch-guidelines/assets/event_flow.drawio.B6f-_ZLD.png" alt="非同期のイベントフロー図"></p><p>シーケンス図のサンプル（meramid.js）。機能設計書であれば本来はビジネスロジックやDBへのCRUDを丁寧に書くべきであるが、サンプルのため割愛。</p><div class="mermaid"></div></div><h3 id="インタフェース定義" tabindex="-1">インタフェース定義 <a class="header-anchor" href="#インタフェース定義" aria-label="Permalink to &quot;インタフェース定義&quot;">​</a></h3><p>特定のWeb APIからのみキューに送信する場合、実質Web API定義に包含されるようなメッセージ定義となる。そのため、メッセージのインタフェース定義は余計な作業ではないかという意見もある。</p><p>推奨は以下の通り。</p><ul><li>限られたWeb APIからのみしか、キューに送信されなかったとしても、メッセージのインタフェース定義を作成する <ul><li>一律、インタフェース定義を設けることで、抜け漏れを防ぎやすい</li><li>プロデューサーではなく、コンシューマー側との認識齟齬を防ぐことができるため。特にスキーマ変更が発生した場合のやり取りを定型的な手順にできるため</li><li>リランなど運用時への情報提供にも繋がるため</li></ul></li><li>キューに送信するメッセージのスキーマは、<a href="https://www.asyncapi.com/" target="_blank" rel="noreferrer">AsyncAPI</a>で記述する <ul><li>JSON Schemaに比べてより表現力が豊富なため（JSON Schemaがペイロードの構造を定義できるが、AsyncAPIは「どのトピック/キューに」 「どの操作（Pub/Sub）で」 「どのペイロードスキーマ」を流すかといった、非同期特有のプロトコル全体を定義できるため）</li><li>定義ファイルをGitで構成管理したり、コード生成に利用することで、インタフェース定義と実装の陳腐化を防ぐことができるため</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">AsyncAPI例</p><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">asyncapi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Order Processing API</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">注文作成から決済処理への非同期イベント連携定義</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 接続定義</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">servers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  productionSqs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sqs.ap-northeast-1.amazonaws.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sqs</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">AWS SQS (Tokyo Region)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># キュー定義</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">channels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  order-created-queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://sqs.ap-northeast-1.amazonaws.com/123456789012/order-created-queue&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">注文が作成されたときにイベントが送信されるSQSキュー</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 操作の定義</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    operations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      sendOrderCreated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;send&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        summary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(プロデューサー) 注文サービスが注文作成イベントを送信する</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        messages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">$ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#/components/messages/OrderCreatedEvent&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      receiveOrderCreated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;receive&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        summary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(コンシューマー) 決済サービスがイベントを受信し処理する</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        messages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">$ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#/components/messages/OrderCreatedEvent&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  messages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    OrderCreatedEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">OrderCreatedEvent</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      summary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">注文が作成されたことを示すイベント</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      contentType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">application/json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      payload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        $ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#/components/schemas/OrderCreatedPayload&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      headers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">object</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div></div><h3 id="キュー定義" tabindex="-1">キュー定義 <a class="header-anchor" href="#キュー定義" aria-label="Permalink to &quot;キュー定義&quot;">​</a></h3><p>インフラレベルのキュー設定は、Terraformなどで管理されていれば、例えば保持期間などの情報はダブルメンテになるため、SSoT（信頼できる唯一の情報源）の観点から記載しない。一方で、IaCからは読み取れない、設計情報や、運用時に必要な情報は記載をまとめる必要がある。</p><p>キュー定義一覧例:</p><ul><li>目的: 「どのキューが、どのビジネス処理のために、どのコンポーネント間で使われているか」を一覧化する</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">キュー名</th><th style="text-align:left;">ビジネス上の用途</th><th style="text-align:left;">プロデューサー (機能ID)</th><th style="text-align:left;">コンシューマー (機能ID)</th><th style="text-align:left;">DLQ</th></tr></thead><tbody><tr><td style="text-align:left;">order-queue</td><td style="text-align:left;">注文情報の非同期登録</td><td style="text-align:left;">API-001 (注文API)</td><td style="text-align:left;">Consumer-001 (注文処理タスク)</td><td style="text-align:left;">order-dlq</td></tr><tr><td style="text-align:left;">payment-queue</td><td style="text-align:left;">決済処理の実行</td><td style="text-align:left;">Consumer-001 (注文処理API)</td><td style="text-align:left;">Consumer-002 (決済処理タスク)</td><td style="text-align:left;">payment-dlq</td></tr><tr><td style="text-align:left;">notification-queue</td><td style="text-align:left;">完了通知の送信</td><td style="text-align:left;">Consumer-002 (決済処理API)</td><td style="text-align:left;">Consumer-003 (通知タスク)</td><td style="text-align:left;">notification-dlq</td></tr></tbody></table><p>DLQ運用一覧例:</p><ul><li>目的: 障害発生時（DLQにメッセージが入った時）に、誰が、何をすべきか」を明確にすること</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">DLQ名 （※）</th><th style="text-align:left;">担当者</th><th style="text-align:left;">手順概要</th><th style="text-align:left;">リカバリ手順</th></tr></thead><tbody><tr><td style="text-align:left;">order-dlq</td><td style="text-align:left;">EC開発チーム</td><td style="text-align:left;">顧客CSチームに連絡後、原因調査。バグ修正デプロイ後に手動でリドライブ</td><td style="text-align:left;">[手順書Aへのリンク] (...)</td></tr><tr><td style="text-align:left;">payment-dlq</td><td style="text-align:left;">決済基盤チーム</td><td style="text-align:left;">決済GWの障害復旧を確認後、リランバッチを実行</td><td style="text-align:left;">[手順書Bへのリンク] (...)</td></tr><tr><td style="text-align:left;">notification-dlq</td><td style="text-align:left;">EC開発チーム</td><td style="text-align:left;">即時リカバリ不要。週次バッチでリトライ。7日経過後は消失を許容</td><td style="text-align:left;">[手順書Cへのリンク] (...)</td></tr></tbody></table><p>※IaC側で記載されているのであれば、該当ファイルへのリンク化することが望ましい。DLQ転送条件やメッセージ保持期間もIaCファイルでカバーする。</p><h3 id="プロデューサー-コンシューマーの機能設計書" tabindex="-1">プロデューサー/コンシューマーの機能設計書 <a class="header-anchor" href="#プロデューサー-コンシューマーの機能設計書" aria-label="Permalink to &quot;プロデューサー/コンシューマーの機能設計書&quot;">​</a></h3><p>非同期プログラムそれぞれの設計書は、通常のビジネスロジック定義（Web API、バッチ、I/Fなど）と変わらないため、必要なCRUDやシーケンス図などを記載する。</p><div class="info custom-block"><p class="custom-block-title">参考</p><ul><li><a href="https://future-architect.github.io/arch-guidelines/documents/forMarkdown/markdown_design_document.html#%E3%83%95%E3%82%9A%E3%83%AD%E3%82%AF%E3%82%99%E3%83%A9%E3%83%A0%E8%A8%AD%E8%A8%88%E6%9B%B8-%E3%83%8F%E3%82%99%E3%83%83%E3%83%81%E3%80%81%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AA%E3%81%A8%E3%82%99" target="_blank" rel="noreferrer">プログラム設計書 | Markdown設計ドキュメント規約</a></li></ul></div><h2 id="謝辞" tabindex="-1">謝辞 <a class="header-anchor" href="#謝辞" aria-label="Permalink to &quot;謝辞&quot;">​</a></h2><p>このアーキテクチャガイドラインの作成には多くの方々にご協力いただいた。心より感謝申し上げる。</p><ul><li>作成者: 真野隼記、武田大輝、亀井隆徳、佐藤尭彰、山口真明、坂本慎司、越島亮介、宮崎将太、澁川喜規</li><li>レビュアー: 募集中</li></ul></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><div class="edit-link" data-v-1bcd8184><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/future-architect/arch-guidelines/edit/main/documents/forAsync/async_guidelines.md" target="_blank" rel="noreferrer" data-v-1bcd8184><!--[--><span class="vpi-square-pen edit-link-icon" data-v-1bcd8184></span> Edit this page<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/arch-guidelines/documents/forAsync/" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Previous page</span><span class="title" data-v-1bcd8184>Introduction</span><!--]--></a></div><div class="pager" data-v-1bcd8184><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><!----><p class="copyright" data-v-566314d4>Copyright 2026 by Future Corporation</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"documents_forasync_async_guidelines.md\":\"D0I6SR9o\",\"documents_forasync_index.md\":\"DNJ250xs\",\"documents_foraws_aws_guidelines.md\":\"BgOqMn5T\",\"documents_foraws_index.md\":\"Dc8EV6am\",\"documents_forbatch_batch_guidelines.md\":\"wBdgS4uN\",\"documents_forbatch_index.md\":\"CxoKFCSh\",\"documents_forcodereview_code_review.md\":\"DemqZV8m\",\"documents_forcodereview_index.md\":\"4G2rM1Ic\",\"documents_fordatamanagement_datamanagement_guidelines.md\":\"P_GOmz5g\",\"documents_fordatamanagement_index.md\":\"_BRHs77b\",\"documents_fordb_dynamodb_guidelines.md\":\"2O4QgGzC\",\"documents_fordb_index.md\":\"CrTOP-9n\",\"documents_fordb_postgresql_guidelines.md\":\"JSyyrWIl\",\"documents_forgitbranch_git_branch_standards.md\":\"anXsu_3J\",\"documents_forgitbranch_index.md\":\"bgYwufIm\",\"documents_forgitbranch_vscode_git_operation.md\":\"mIsYzj0Z\",\"documents_forif_if_guidelines.md\":\"B3kSXIff\",\"documents_forif_index.md\":\"CcIF7z1z\",\"documents_forlog_index.md\":\"DanJeB_3\",\"documents_forlog_log_guidelines.md\":\"B4Of-IFK\",\"documents_formail_index.md\":\"BOZHj6By\",\"documents_formail_mail_guidelines.md\":\"D9cx11k2\",\"documents_formarkdown_index.md\":\"DVRc4nD1\",\"documents_formarkdown_markdown_design_document.md\":\"8j2o9lWn\",\"documents_formarkdown_sample_api_reference.md\":\"CCokJ1No\",\"documents_formarkdown_sample_erd_reference.md\":\"DHBHmlNl\",\"documents_formarkdown_sample_index.md\":\"BVITEOxo\",\"documents_formarkdown_sample_ui_index.md\":\"D7-m9l6o\",\"documents_formarkdown_sample_ui_uim01_index.md\":\"Leso9dOR\",\"documents_formarkdown_sample_ui_uim02_index.md\":\"x9UkDHZm\",\"documents_formarkdown_sample_ui_uim03_index.md\":\"Dy-pUdjt\",\"documents_formarkdown_sample_ui_uim04_index.md\":\"xpLKO1YT\",\"documents_formarkdown_sample_ui_uis01_index.md\":\"CCMl_LG4\",\"documents_formarkdown_sample_ui_uis02_index.md\":\"DmeCPWZR\",\"documents_formarkdown_sample_ui_uis03_index.md\":\"Cws3CaAV\",\"documents_formarkdown_sample_ui_uis04_index.md\":\"C14cCrxv\",\"documents_forreport_index.md\":\"wSaz7LE_\",\"documents_forreport_report_guidelines.md\":\"DfgYg5Ie\",\"documents_forslack_index.md\":\"BNDMJnM-\",\"documents_forslack_slack_usage_guidelines.md\":\"DcHdFhND\",\"documents_forsoftskill_index.md\":\"D25uYrXY\",\"documents_forsoftskill_softskill_guidelines.md\":\"S-EA12Or\",\"documents_forterraform_index.md\":\"BNIXOvyM\",\"documents_forterraform_terraform_guidelines.md\":\"D73Iyn2G\",\"documents_forwebapi_index.md\":\"97ZO_BGW\",\"documents_forwebapi_web_api_guidelines.md\":\"BgJjG0fw\",\"documents_forwebfrontend_index.md\":\"nOwqcUWZ\",\"documents_forwebfrontend_web_frontend_guidelines.md\":\"BmjRtmoZ\",\"index.md\":\"CE5lk6qq\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"フューチャー株式会社\",\"description\":\"フューチャー株式会社の有志が作成する<br>良いアーキテクチャを実現するための設計ガイドライン\",\"base\":\"/arch-guidelines/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"siteTitle\":\"Future <wbr>Architecture Guidelines\",\"logo\":{\"light\":\"/images/logo.svg\",\"dark\":\"/images/logo-dark.svg\"},\"footer\":{\"copyright\":\"Copyright 2026 by Future Corporation\"},\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"editLink\":{\"pattern\":\"https://github.com/future-architect/arch-guidelines/edit/main/:path\"},\"outline\":{\"level\":\"deep\"},\"nav\":[{\"text\":\"Guidelines\",\"items\":[{\"text\":\"アプリケーション\",\"items\":[{\"text\":\"Web フロントエンド\",\"link\":\"/documents/forWebFrontend/web_frontend_guidelines.html\"},{\"text\":\"Web API\",\"link\":\"/documents/forWebAPI/web_api_guidelines.html\"},{\"text\":\"非同期\",\"link\":\"/documents/forAsync/async_guidelines.html\"},{\"text\":\"バッチ\",\"link\":\"/documents/forBatch/batch_guidelines.html\"},{\"text\":\"I/F\",\"link\":\"/documents/forIF/if_guidelines.html\"},{\"text\":\"メール\",\"link\":\"/documents/forMail/mail_guidelines.html\"},{\"text\":\"ログ\",\"link\":\"/documents/forLog/log_guidelines.html\"}]},{\"text\":\"DB\",\"items\":[{\"text\":\"PostgreSQL\",\"link\":\"/documents/forDB/postgresql_guidelines.html\"},{\"text\":\"DynamoDB\",\"link\":\"/documents/forDB/dynamodb_guidelines.html\"},{\"text\":\"データマネジメント\",\"link\":\"/documents/forDataManagement/datamanagement_guidelines.html\"}]},{\"text\":\"インフラ\",\"items\":[{\"text\":\"AWS\",\"link\":\"/documents/forAWS/aws_guidelines.html\"},{\"text\":\"Terraform\",\"link\":\"/documents/forTerraform/terraform_guidelines.html\"}]},{\"text\":\"開発生産性\",\"items\":[{\"text\":\"Gitブランチフロー\",\"link\":\"/documents/forGitBranch/git_branch_standards.html\"},{\"text\":\"Markdown設計ドキュメント\",\"link\":\"/documents/forMarkdown/markdown_design_document.html\"},{\"text\":\"コードレビュー\",\"link\":\"/documents/forCodeReview/code_review.html\"},{\"text\":\"Slack利用\",\"link\":\"/documents/forSlack/slack_usage_guidelines.html\"}]},{\"text\":\"その他\",\"items\":[{\"text\":\"ソフトスキル\",\"link\":\"/documents/forSoftSkill/softskill_guidelines.html\"}]}]},{\"text\":\"About Us\",\"items\":[{\"text\":\"フューチャー株式会社\",\"link\":\"https://www.future.co.jp/\"},{\"text\":\"Blog\",\"link\":\"https://future-architect.github.io/\"},{\"text\":\"Qiita\",\"link\":\"https://qiita.com/organizations/future\"},{\"text\":\"X\",\"link\":\"https://twitter.com/future_techblog\"},{\"text\":\"Facebook\",\"link\":\"https://www.facebook.com/future.saiyo/\"},{\"text\":\"Email <techblog@future.co.jp>\",\"link\":\"mailto:techblog@future.co.jp\"}]}],\"sidebar\":{\"/documents/forWebFrontend/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forWebFrontend/\"},{\"text\":\"Webフロントエンド設計ガイドライン\",\"link\":\"/documents/forWebFrontend/web_frontend_guidelines.html\"}],\"/documents/forWebAPI/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forWebAPI/\"},{\"text\":\"Web API設計ガイドライン\",\"link\":\"/documents/forWebAPI/web_api_guidelines.html\"}],\"/documents/forBatch/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forBatch/\"},{\"text\":\"バッチ設計ガイドライン\",\"link\":\"/documents/forBatch/batch_guidelines.html\"}],\"/documents/forIF/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forIF/\"},{\"text\":\"I/F設計ガイドライン\",\"link\":\"/documents/forIF/if_guidelines.html\"}],\"/documents/forAsync/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forAsync/\"},{\"text\":\"非同期設計ガイドライン\",\"link\":\"/documents/forAsync/async_guidelines.html\"}],\"/documents/forReport/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forReport/\"},{\"text\":\"帳票設計ガイドライン\",\"link\":\"/documents/forMail/report_guidelines.html\"}],\"/documents/forMail/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forMail/\"},{\"text\":\"メール設計ガイドライン\",\"link\":\"/documents/forMail/mail_guidelines.html\"}],\"/documents/forLog/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forLog/\"},{\"text\":\"ログ設計ガイドライン\",\"link\":\"/documents/forLog/log_guidelines.html\"}],\"/documents/forDB/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forDB/\"},{\"text\":\"PostgreSQL設計ガイドライン\",\"link\":\"/documents/forDB/postgresql_guidelines.html\"},{\"text\":\"DynamoDB設計ガイドライン\",\"link\":\"/documents/forDB/dynamodb_guidelines.html\"}],\"/documents/forAWS/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forAWS/\"},{\"text\":\"AWS設計ガイドライン\",\"link\":\"/documents/forAWS/aws_guidelines.html\"}],\"/documents/forTerraform/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forTerraform/\"},{\"text\":\"Terraform設計ガイドライン\",\"link\":\"/documents/forTerraform/terraform_guidelines.html\"}],\"/documents/forDataManagement/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forDataManagement/\"},{\"text\":\"データマネジメント設計ガイドライン\",\"link\":\"/documents/forDataManagement/datamanagement_guidelines.html\"}],\"/documents/forGitBranch/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forGitBranch/\"},{\"text\":\"Gitブランチフロー規約\",\"link\":\"/documents/forGitBranch/git_branch_standards.html\"},{\"text\":\"VS Code Git操作\",\"link\":\"/documents/forGitBranch/vscode_git_operation.html\"}],\"/documents/forMarkdown/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forMarkdown/\"},{\"text\":\"Markdown設計ドキュメント規約\",\"link\":\"/documents/forMarkdown/markdown_design_document.html\"},{\"text\":\"サンプルプロジェクト\",\"link\":\"/documents/forMarkdown/sample\",\"items\":[{\"text\":\"画面一覧\",\"link\":\"/documents/forMarkdown/sample/ui\",\"items\":[{\"text\":\"UIS01\",\"link\":\"/documents/forMarkdown/sample/ui/UIS01\"},{\"text\":\"UIS02\",\"link\":\"/documents/forMarkdown/sample/ui/UIS02\"},{\"text\":\"UIS03\",\"link\":\"/documents/forMarkdown/sample/ui/UIS03\"},{\"text\":\"UIS04\",\"link\":\"/documents/forMarkdown/sample/ui/UIS04\"},{\"text\":\"UIM01\",\"link\":\"/documents/forMarkdown/sample/ui/UIM01\"},{\"text\":\"UIM02\",\"link\":\"/documents/forMarkdown/sample/ui/UIM02\"},{\"text\":\"UIM03\",\"link\":\"/documents/forMarkdown/sample/ui/UIM03\"},{\"text\":\"UIM04\",\"link\":\"/documents/forMarkdown/sample/ui/UIM04\"}]}]}],\"/documents/forSlack/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forSlack/\"},{\"text\":\"Slack利用ガイドライン\",\"link\":\"/documents/forSlack/slack_usage_guidelines.html\"}],\"/documents/forCodeReview/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forCodeReview/\"},{\"text\":\"コードレビューガイドライン\",\"link\":\"/documents/forCodeReview/code_review.html\"}],\"/documents/forSoftSkill/\":[{\"text\":\"Introduction\",\"link\":\"/documents/forSoftSkill/\"},{\"text\":\"ソフトスキルガイドライン\",\"link\":\"/documents/forSoftSkill/softskill_guidelines.html\"}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/future-architect/arch-guidelines\"}]},\"locales\":{\"root\":{\"lang\":\"ja\"}},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>